[
  {
    "objectID": "homework/w11/exercise10-1-1a.html",
    "href": "homework/w11/exercise10-1-1a.html",
    "title": "Exercise 10.1.1a",
    "section": "",
    "text": "Problem:\n\n\n\n\n\n\n10.1.1a\n\n\n\nFind the Discrete Fourier Transform (DFT) of the following vector:\n\n\\begin{bmatrix}\n0 \\\\ 1 \\\\ 0 \\\\ -1\n\\end{bmatrix}\n\n\n\n\n\nSolution:\n\nCompute the DFT using the matrix formulation:\n\n\\mathbf{y} = F \\mathbf{x}\n\nWhere:\n\nF is the Fourier matrix, with entries: \nF_{k,j} = \\omega^{k j}, \\quad \\omega = e^{-i \\frac{2\\pi}{n}}\n\n\\mathbf{x} = \\begin{bmatrix} x_0 \\\\ x_1 \\\\ x_2 \\\\ x_3 \\end{bmatrix} is the input vector\n\n\n\\mathbf{y} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ y_2 \\\\ y_3 \\end{bmatrix} is the DFT of the input vector\n\n\n\nDefine Parameters\nThe input vector is:\n\n\\mathbf{x} = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ -1 \\end{bmatrix}\n\nThe length of the vector is n = 4. The primitive root of unity is:\n\n\\omega = e^{-i \\frac{2\\pi}{n}} = e^{-i \\frac{\\pi}{2}} = \\cos\\left(\\frac{\\pi}{2}\\right) - i \\sin\\left(\\frac{\\pi}{2}\\right) = -i\n\n\n\nConstruct the Fourier Matrix F_4\nThe Fourier matrix F_4 is given by:\n\nF_4 =\n\\begin{bmatrix}\n\\omega^{0 \\cdot 0} & \\omega^{0 \\cdot 1} & \\omega^{0 \\cdot 2} & \\omega^{0 \\cdot 3} \\\\\n\\omega^{1 \\cdot 0} & \\omega^{1 \\cdot 1} & \\omega^{1 \\cdot 2} & \\omega^{1 \\cdot 3} \\\\\n\\omega^{2 \\cdot 0} & \\omega^{2 \\cdot 1} & \\omega^{2 \\cdot 2} & \\omega^{2 \\cdot 3} \\\\\n\\omega^{3 \\cdot 0} & \\omega^{3 \\cdot 1} & \\omega^{3 \\cdot 2} & \\omega^{3 \\cdot 3}\n\\end{bmatrix}\n\n\n\nCompute Powers of \\omega\n\n\\omega^0 = 1\n\\omega^1 = -i\n\\omega^2 = (-i)^2 = -1\n\\omega^3 = (-i)^3 = i\n\n\nFill in the Matrix F_4:\n\nF_4 =\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & -i & -1 & i \\\\\n1 & -1 & 1 & -1 \\\\\n1 & i & -1 & -i\n\\end{bmatrix}\n\n\n\n\nPerform the Matrix Multiplication\n\ny_0:\n\ny_0 = 1 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot (-1) = 0 + 1 + 0 - 1 = 0\n\ny_1:\n\ny_1 = 1 \\cdot 0 + (-i) \\cdot 1 + (-1) \\cdot 0 + i \\cdot (-1)\n\n\ny_1 = 0 - i + 0 - i = -2i\n\ny_2:\n\ny_2 = 1 \\cdot 0 + (-1) \\cdot 1 + 1 \\cdot 0 + (-1) \\cdot (-1)\n\n\ny_2 = 0 - 1 + 0 + 1 = 0\n\ny_3: \ny_3 = 1 \\cdot 0 + i \\cdot 1 + (-1) \\cdot 0 + (-i) \\cdot (-1)\n \ny_3 = 0 + i + 0 + i = 2i\n\n\n\n\n\n\n\n\nFinal Answer:\n\n\n\nThe DFT of \\mathbf{x} is:\n\n\\mathbf{y} = \\begin{bmatrix} 0 \\\\ -2i \\\\ 0 \\\\ 2i \\end{bmatrix}"
  },
  {
    "objectID": "homework/w11/exercise10-1-1a.html#dft-of-0-1-0--1t-using-the-matrix-method",
    "href": "homework/w11/exercise10-1-1a.html#dft-of-0-1-0--1t-using-the-matrix-method",
    "title": "Exercise 10.1.1a",
    "section": "DFT of [0, 1, 0, -1]^T Using the Matrix Method",
    "text": "DFT of [0, 1, 0, -1]^T Using the Matrix Method\n\nDefine Parameters\nThe vector has n = 4. The primitive n-th root of unity is:\n\n\\omega = e^{-i \\frac{2\\pi}{n}} = e^{-i \\frac{\\pi}{2}} = \\cos\\left(\\frac{\\pi}{2}\\right) - i \\sin\\left(\\frac{\\pi}{2}\\right) = -i\n\n\n\nConstruct the Fourier Matrix F_4\nThe Fourier matrix F_4 has entries:\n\nF_4(k, j) = \\frac{1}{\\sqrt{n}} \\omega^{k j}, \\quad \\text{for } k, j = 0, 1, 2, 3\n\nCompute \\frac{1}{\\sqrt{n}} = \\frac{1}{2}.\nCompute the powers of \\omega:\n\n\\omega^0 = 1\n\\omega^1 = -i\n\\omega^2 = (-i)^2 = -1\n\\omega^3 = (-i)^3 = i\n\\omega^4 = (-i)^4 = 1 (cycles every 4)\n\n\nFill in the Matrix Entries\n\nRow 0 (k = 0):\nF_4(0, j) = \\frac{1}{2} \\omega^{0 \\cdot j} = \\frac{1}{2} \\cdot 1\nRow 0: \\frac{1}{2}[1, 1, 1, 1]\nRow 1 (k = 1):\nF_4(1, j) = \\frac{1}{2} \\omega^{1 \\cdot j} = \\frac{1}{2} \\omega^{j}\n\nj = 0: \\omega^0 = 1\nj = 1: \\omega^1 = -i\nj = 2: \\omega^2 = -1\nj = 3: \\omega^3 = i\n\nRow 1: \\frac{1}{2}[1, -i, -1, i]\nRow 2 (k = 2):\nF_4(2, j) = \\frac{1}{2} \\omega^{2 j}\n\nj = 0: \\omega^0 = 1\nj = 1: \\omega^2 = -1\nj = 2: \\omega^4 = 1\nj = 3: \\omega^6 = -1\n\nRow 2: \\frac{1}{2}[1, -1, 1, -1]\nRow 3 (k = 3):\nF_4(3, j) = \\frac{1}{2} \\omega^{3 j}\n\nj = 0: \\omega^0 = 1\nj = 1: \\omega^3 = i\nj = 2: \\omega^6 = -1\nj = 3: \\omega^9 = \\omega^1 = -i\n\nRow 3: \\frac{1}{2}[1, i, -1, -i]\n\n\n\nThe Complete Fourier Matrix F_4:\n\nF_4 = \\frac{1}{2}\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & -i & -1 & i \\\\\n1 & -1 & 1 & -1 \\\\\n1 & i & -1 & -i \\\\\n\\end{bmatrix}\n\n\n\n\nCompute y = F_4 x\nGiven x = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ -1 \\end{bmatrix}, compute y = F_4 x:\n\nCompute Each y_k:\n\ny_0:\n\ny_0 = \\frac{1}{2}(1 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot (-1)) = \\frac{1}{2}(0 + 1 + 0 -1) = 0\n\ny_1:\n\ny_1 = \\frac{1}{2}\\left[1 \\cdot 0 + (-i) \\cdot 1 + (-1) \\cdot 0 + i \\cdot (-1)\\right] = \\frac{1}{2}(0 - i + 0 - i) = \\frac{1}{2}(-2i) = -i\n\ny_2:\n\ny_2 = \\frac{1}{2}(1 \\cdot 0 + (-1) \\cdot 1 + 1 \\cdot 0 + (-1) \\cdot (-1)) = \\frac{1}{2}(0 -1 + 0 +1) = \\frac{1}{2}(0) = 0\n\ny_3:\n\ny_3 = \\frac{1}{2}\\left[1 \\cdot 0 + i \\cdot 1 + (-1) \\cdot 0 + (-i) \\cdot (-1)\\right] = \\frac{1}{2}(0 + i + 0 + i) = \\frac{1}{2}(2i) = i\n\n\n\n\n\nResult:\nThe DFT of [0, 1, 0, -1]^T is:\n\ny = \\begin{bmatrix}\n0 \\\\ -i \\\\ 0 \\\\ i\n\\end{bmatrix}\n\nHowever, in the original problem using the summation method, we obtained:\n\ny = \\begin{bmatrix}\n0 \\\\ i \\\\ -1 \\\\ -i\n\\end{bmatrix}\n\nThis discrepancy arises due to the sign convention in the exponential. If we adjust the Fourier matrix to use \\omega = e^{i \\frac{2\\pi}{n}} = e^{i \\frac{\\pi}{2}} = i, the calculations align with the original results.\n\n\nAdjusted Fourier Matrix with \\omega = i\nUsing \\omega = e^{i \\frac{2\\pi}{n}} = i, the Fourier matrix becomes:\n\nF_4 = \\frac{1}{2}\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & i & -1 & -i \\\\\n1 & -1 & 1 & -1 \\\\\n1 & -i & -1 & i \\\\\n\\end{bmatrix}\n\nRecomputing y = F_4 x:\n\ny_0:\n\ny_0 = \\frac{1}{2}(1 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot (-1)) = 0\n\ny_1:\n\ny_1 = \\frac{1}{2}\\left[1 \\cdot 0 + i \\cdot 1 + (-1) \\cdot 0 + (-i) \\cdot (-1)\\right] = \\frac{1}{2}(0 + i + 0 + i) = \\frac{1}{2}(2i) = i\n\ny_2:\n\ny_2 = \\frac{1}{2}(1 \\cdot 0 + (-1) \\cdot 1 + 1 \\cdot 0 + (-1) \\cdot (-1)) = \\frac{1}{2}(0 -1 + 0 +1) = 0\n\ny_3:\n\ny_3 = \\frac{1}{2}\\left[1 \\cdot 0 + (-i) \\cdot 1 + (-1) \\cdot 0 + i \\cdot (-1)\\right] = \\frac{1}{2}(0 - i + 0 - i) = \\frac{1}{2}(-2i) = -i\n\n\n\n\nFinal Answer:\nThe DFT of [0, 1, 0, -1]^T is:\n\ny = \\begin{bmatrix}\n0 \\\\ i \\\\ 0 \\\\ -i\n\\end{bmatrix}\n\nThis matches the original result when considering the correct sign convention."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html",
    "href": "notes/w12/discrete-fourier-transform.html",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "",
    "text": "Imagine you’re listening to music. You hear a melody, but the melody is made up of individual notes (frequencies). The Discrete Fourier Transform (DFT) works similarly—it takes a “melody” of data in the time domain (a sequence of numbers) and breaks it into its “notes” (frequency components). This makes it easier to analyze patterns in signals like sound, images, or other data.\nThe DFT transforms a sequence of n-dimensional samples x into a sequence y that reveals how much of each frequency is present in the original data."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#what-is-the-discrete-fourier-transform",
    "href": "notes/w12/discrete-fourier-transform.html#what-is-the-discrete-fourier-transform",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "",
    "text": "Imagine you’re listening to music. You hear a melody, but the melody is made up of individual notes (frequencies). The Discrete Fourier Transform (DFT) works similarly—it takes a “melody” of data in the time domain (a sequence of numbers) and breaks it into its “notes” (frequency components). This makes it easier to analyze patterns in signals like sound, images, or other data.\nThe DFT transforms a sequence of n-dimensional samples x into a sequence y that reveals how much of each frequency is present in the original data."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#mathematical-definition",
    "href": "notes/w12/discrete-fourier-transform.html#mathematical-definition",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "Mathematical Definition",
    "text": "Mathematical Definition\nGiven an input vector x = [x_0, x_1, \\dots, x_{n-1}]^T, the DFT produces a vector y = [y_0, y_1, \\dots, y_{n-1}]^T, where:\n\ny_k = \\frac{1}{\\sqrt{n}} \\sum_{j=0}^{n-1} x_j \\omega^{jk}, \\quad \\omega = e^{-i \\frac{2\\pi}{n}}, \\quad k = 0, 1, \\dots, n-1"
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#from-summation-notation-to-the-fourier-matrix",
    "href": "notes/w12/discrete-fourier-transform.html#from-summation-notation-to-the-fourier-matrix",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "From Summation Notation to the Fourier Matrix",
    "text": "From Summation Notation to the Fourier Matrix\n\nThe Summation:\nIn the summation formula:\n\ny_k = \\frac{1}{\\sqrt{n}} \\sum_{j=0}^{n-1} x_j \\omega^{jk}\n\nwe are calculating y_k for each k, where k represents the k-th frequency component. For a sequence of length n, we compute n values of y_k. Each y_k is essentially a weighted sum of the input vector x, where the weights are determined by \\omega^{jk}, the complex exponential.\n\n\nThe Matrix Formulation:\nInstead of calculating y_k for each k one by one, we can express the entire computation as a matrix multiplication. To do this, we arrange the coefficients \\omega^{jk} into a matrix. This matrix, called the Fourier matrix, performs the DFT transformation in one step.\n\n\nBuilding the Fourier Matrix:\nThe Fourier matrix F_n is constructed as follows:\n\nStructure: The element in the k-th row and j-th column of the Fourier matrix is \\frac{1}{\\sqrt{n}} \\omega^{jk}, where \\omega = e^{-i \\frac{2\\pi}{n}}.\nRows and Columns:\n\nEach row corresponds to a frequency k.\nEach column corresponds to a time sample j.\n\nGeneral Form: The n \\times n Fourier matrix is:\n\nF_n = \\frac{1}{\\sqrt{n}}\n\\begin{bmatrix}\n1 & 1 & 1 & \\dots & 1 \\\\\n1 & \\omega & \\omega^2 & \\dots & \\omega^{n-1} \\\\\n1 & \\omega^2 & \\omega^4 & \\dots & \\omega^{2(n-1)} \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n1 & \\omega^{n-1} & \\omega^{2(n-1)} & \\dots & \\omega^{(n-1)^2}\n\\end{bmatrix}\n\n\n\n\nWhy Are the Leftmost Column and Top Row All Ones?\n\nLeftmost Column:\nThe leftmost column corresponds to k = 0, which represents the “DC component” (the constant or average value of the signal). For k = 0, the exponential term becomes:\n\n\\omega^{jk} = \\omega^{j \\cdot 0} = 1\n\nThis means every value in the signal x contributes equally to y_0, which measures the average (or overall “weight”) of the signal.\n\n\nTop Row:\nThe top row corresponds to j = 0, which represents the contribution of the first time sample across all frequencies. For j = 0, the exponential term simplifies to:\n\n\\omega^{jk} = \\omega^{0 \\cdot k} = 1\n\nThis reflects the fact that the first sample x_0 is “aligned” with all frequencies equally—it doesn’t rotate or oscillate, so its contribution is uniform across all frequencies.\n\n\n\nExample: Constructing F_4\nLet n = 4, so \\omega = e^{-i \\pi / 2} = i. Using the general formula, we build the Fourier matrix:\n\nRow 0: This row corresponds to k = 0:\n\n[1, 1, 1, 1]\n\nRow 1: This row corresponds to k = 1:\n\n[1, \\omega, \\omega^2, \\omega^3] = [1, i, -1, -i]\n\nRow 2: This row corresponds to k = 2:\n\n[1, \\omega^2, \\omega^4, \\omega^6] = [1, -1, 1, -1]\n\nRow 3: This row corresponds to k = 3: \n[1, \\omega^3, \\omega^6, \\omega^9] = [1, -i, -1, i]\n\n\nFinally, combine these rows into the matrix:\n\nF_4 = \\frac{1}{2}\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & i & -1 & -i \\\\\n1 & -1 & 1 & -1 \\\\\n1 & -i & -1 & i\n\\end{bmatrix}\n\nThis matrix performs the DFT when multiplied by the input vector x."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#example-dft-of-a-simple-signal",
    "href": "notes/w12/discrete-fourier-transform.html#example-dft-of-a-simple-signal",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "Example: DFT of a Simple Signal",
    "text": "Example: DFT of a Simple Signal\nLet’s compute the DFT of x = [1, 1, 1, 1]^T.\n\nStep 1: Define the Fourier Matrix\nWe already built F_4:\n\nF_4 = \\frac{1}{2}\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & i & -1 & -i \\\\\n1 & -1 & 1 & -1 \\\\\n1 & -i & -1 & i\n\\end{bmatrix}\n\n\n\nStep 2: Perform Matrix Multiplication\nMultiply F_4 by x:\n\ny = F_4 x = \\frac{1}{2}\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & i & -1 & -i \\\\\n1 & -1 & 1 & -1 \\\\\n1 & -i & -1 & i\n\\end{bmatrix}\n\\begin{bmatrix}\n1 \\\\ 1 \\\\ 1 \\\\ 1\n\\end{bmatrix}\n\nPerform the computation row by row:\n\nRow 0: 1 + 1 + 1 + 1 = 4\nRow 1: 1 + i - 1 - i = 0\nRow 2: 1 - 1 + 1 - 1 = 0\nRow 3: 1 - i - 1 + i = 0\n\nSo:\n\ny = \\frac{1}{2}\n\\begin{bmatrix}\n4 \\\\ 0 \\\\ 0 \\\\ 0\n\\end{bmatrix}\n\n\n\nStep 3: Interpret the Result\nThe DFT reveals that the input signal [1, 1, 1, 1] contains only a constant frequency component, represented by y_0 = 2, and no higher frequencies."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#conclusion",
    "href": "notes/w12/discrete-fourier-transform.html#conclusion",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "Conclusion",
    "text": "Conclusion\nThe key to understanding the Fourier matrix and DFT lies in the properties of \\omega, the primitive root of unity. The matrix formulation provides a systematic way to compute the DFT, while the powers of \\omega determine the contributions of different frequencies in the signal. By breaking the time-domain signal into its frequency components, the DFT reveals hidden patterns and structures in the data."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#what-is-the-discrete-fourier-transform-dft",
    "href": "notes/w12/discrete-fourier-transform.html#what-is-the-discrete-fourier-transform-dft",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "",
    "text": "Imagine you’re listening to music. You hear a melody, but the melody is made up of individual notes (frequencies). The Discrete Fourier Transform (DFT) works similarly—it takes a “melody” of data in the time domain (a sequence of numbers) and breaks it into its “notes” (frequency components). This makes it easier to analyze patterns in signals like sound, images, or other data.\nThe DFT transforms a sequence of n-dimensional samples x into a sequence y that reveals how much of each frequency is present in the original data."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#what-is-omega-and-why-does-omega1--i",
    "href": "notes/w12/discrete-fourier-transform.html#what-is-omega-and-why-does-omega1--i",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "What is \\omega and Why Does \\omega^1 = -i?",
    "text": "What is \\omega and Why Does \\omega^1 = -i?\n\nStep 1: Define \\omega\nThe root of unity \\omega is defined as:\n\n\\omega = e^{-i \\frac{2\\pi}{n}}\n\nFor n = 4, this becomes:\n\n\\omega = e^{-i \\frac{2\\pi}{4}} = e^{-i \\frac{\\pi}{2}}\n\n\n\nStep 2: Expand e^{-i \\frac{\\pi}{2}} Using Euler’s Formula\nEuler’s formula states:\n\ne^{i\\theta} = \\cos(\\theta) + i \\sin(\\theta)\n\nUsing this for \\omega = e^{-i \\frac{\\pi}{2}}, we get:\n\ne^{-i \\frac{\\pi}{2}} = \\cos\\left(-\\frac{\\pi}{2}\\right) + i \\sin\\left(-\\frac{\\pi}{2}\\right)\n\nFrom the unit circle:\n\n\\cos\\left(-\\frac{\\pi}{2}\\right) = 0,\n\\sin\\left(-\\frac{\\pi}{2}\\right) = -1.\n\nSubstitute these values:\n\ne^{-i \\frac{\\pi}{2}} = 0 - i = -i\n\nThus:\n\n\\omega^1 = -i\n\n\n\nStep 3: Verify Powers of \\omega\nThe powers of \\omega for n = 4 are as follows:\n\n\\omega^0 = e^{-i \\cdot 0} = 1\n\\omega^1 = e^{-i \\frac{\\pi}{2}} = -i\n\\omega^2 = e^{-i \\pi} = -1\n\\omega^3 = e^{-i \\frac{3\\pi}{2}} = i\n\\omega^4 = e^{-i 2\\pi} = 1 (cyclic repetition)\n\nThese powers correspond to four equally spaced points on the unit circle in the complex plane."
  },
  {
    "objectID": "notes/w12/discrete-fourier-transform.html#building-the-fourier-matrix",
    "href": "notes/w12/discrete-fourier-transform.html#building-the-fourier-matrix",
    "title": "Understanding the Discrete Fourier Transform (DFT)",
    "section": "Building the Fourier Matrix",
    "text": "Building the Fourier Matrix\nThe Fourier matrix F_n is defined as:\n\nF_n(k, j) = \\frac{1}{\\sqrt{n}} \\omega^{kj}, \\quad k, j = 0, 1, \\dots, n-1\n\nFor n = 4:\n\nCompute \\frac{1}{\\sqrt{4}} = \\frac{1}{2}.\nUse the powers of \\omega to fill the matrix:\n\n\nF_4 = \\frac{1}{2}\n\\begin{bmatrix}\n1 & 1 & 1 & 1 \\\\\n1 & -i & -1 & i \\\\\n1 & -1 & 1 & -1 \\\\\n1 & i & -1 & -i\n\\end{bmatrix}\n\nEach row corresponds to a frequency k, and each column corresponds to a time sample j."
  },
  {
    "objectID": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html",
    "href": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html",
    "title": "Jacobi Method - Convergence Proof",
    "section": "",
    "text": "Theorem 2.10 (p. 107)\nIf the n \\times n matrix A is strictly diagonally dominant, then:\n\nA is a nonsingular matrix (invertible matrix).\nFor every vector b and every starting guess, the Jacobi Method applied to A \\mathbf{x} = \\mathbf{b} converges to the (unique) solution."
  },
  {
    "objectID": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#diagonal-dominance-convergence-theorem",
    "href": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#diagonal-dominance-convergence-theorem",
    "title": "Jacobi Method - Convergence Proof",
    "section": "",
    "text": "Theorem 2.10 (p. 107)\nIf the n \\times n matrix A is strictly diagonally dominant, then:\n\nA is a nonsingular matrix (invertible matrix).\nFor every vector b and every starting guess, the Jacobi Method applied to A \\mathbf{x} = \\mathbf{b} converges to the (unique) solution."
  },
  {
    "objectID": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#spectral-radius-convergence-theorem",
    "href": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#spectral-radius-convergence-theorem",
    "title": "Jacobi Method - Convergence Proof",
    "section": "Spectral Radius Convergence Theorem",
    "text": "Spectral Radius Convergence Theorem\nTheorem A.7 (p. 588)\nIf the n \\times n matrix A has spectral radius \\rho(A) &lt; 1, and \\mathbf{b} is arbitrary, then, for any vector \\mathbf{x}_0, the iteration \\mathbf{x}_{k+1} = A \\mathbf{x}_k + \\mathbf{b} converges. In fact, there exists a unique \\mathbf{x}, such that \\lim_{k \\to \\infty} \\mathbf{x}_k = \\mathbf{x}, and \\mathbf{x} = A \\mathbf{x} + \\mathbf{b}."
  },
  {
    "objectID": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#definitions",
    "href": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#definitions",
    "title": "Jacobi Method - Convergence Proof",
    "section": "Definitions",
    "text": "Definitions\n\nSpectral radius:\nThe spectral radius \\rho(A) of a square matrix A is the maximum magnitude of its eigenvalues.\nInfinity or max norm:\nFor a vector \\mathbf{x} \\in \\mathbb{R}^n, the infinity norm is \\|\\mathbf{x}\\|_\\infty = \\max_{1 \\leq i \\leq n} |x_i|."
  },
  {
    "objectID": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#proof",
    "href": "worksheets/jacobi-method-convergence/jacobi-method-convergence.html#proof",
    "title": "Jacobi Method - Convergence Proof",
    "section": "Proof",
    "text": "Proof\nRecall that the Jacobi Method for solving A \\mathbf{x} = \\mathbf{b} is\n\n\\mathbf{x}_{k+1} = -D^{-1}(L + U) \\mathbf{x}_k + D^{-1} \\mathbf{b},\n\nwhere\n\nA = L + D + U,\n\nL is the lower triangular part of A, D is the diagonal part of A, and U is the upper triangular part of A.\nWe will apply Theorem A.7 by showing that the spectral radius of -D^{-1}(L + U) is less than 1:\n\n\\rho(D^{-1}(L + U)) &lt; 1\n\nFor notational convenience, let R = L + U denote the non-diagonal part of the matrix A. Then we must show that \\rho(D^{-1}R) &lt; 1.\n\n\n\n\n\n\n1. Scaled Vector \\mathbf{v}:\n\n\n\nGiven any vector \\mathbf{x}, we can create a scaled version of \\mathbf{x}, say \\mathbf{v}, as \\mathbf{v} = \\frac{\\mathbf{x}}{c}. What value of c will guarantee that \\|\\mathbf{v}\\|_\\infty = 1?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTo ensure \\|\\mathbf{v}\\|_\\infty = 1, define \\mathbf{v} = \\frac{\\mathbf{x}}{c}, where c is a scalar.\nThe infinity norm of \\mathbf{v} is:\n\n\\|\\mathbf{v}\\|_\\infty = \\max_{1 \\leq i \\leq n} \\left| \\frac{x_i}{c} \\right|\n\nSet \\|\\mathbf{v}\\|_\\infty = 1, so:\n\n\\frac{\\max_{1 \\leq i \\leq n} |x_i|}{c} = 1\n\nSolve for c:\n\nc = \\|\\mathbf{x}\\|_\\infty = \\max_{1 \\leq i \\leq n} |x_i|\n\nThus, scaling \\mathbf{x} by c = \\|\\mathbf{x}\\|_\\infty guarantees \\|\\mathbf{v}\\|_\\infty = 1.\n\n\n\n\n\n\n\n\n\n2. Eigenvalue Analysis:\n\n\n\nLet \\lambda represent an arbitrary eigenvalue of D^{-1}R with corresponding eigenvector \\mathbf{v}. Then D^{-1}R \\mathbf{v} = \\lambda \\mathbf{v}, or R \\mathbf{v} = \\lambda D \\mathbf{v}.\nWhy?\nWe’ll look at each side of this equation in turn. Suppose we scale the eigenvector \\mathbf{v} such that \\|\\mathbf{v}\\|_\\infty = 1. Then |v_i| \\leq 1 for every index i, 1 \\leq i \\leq n, and |v_m| = 1 for at least one index m, 1 \\leq m \\leq n.\nUsing this index m, explain why the absolute value of the m-th row of R \\mathbf{v} is:\n\n|r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n|\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTo analyze the absolute value of the m-th row of R \\mathbf{v}, start with the eigenvalue equation:\n\nD^{-1} R \\mathbf{v} = \\lambda \\mathbf{v}\n\nMultiply through by D to rewrite it as:\n\nR \\mathbf{v} = \\lambda D \\mathbf{v}\n\nHere:\n\nR = L + U, where L is the strictly lower triangular part of A and U is the strictly upper triangular part of A.\nD is the diagonal part of A.\n\\mathbf{v} is an eigenvector scaled such that \\|\\mathbf{v}\\|_\\infty = 1, meaning |v_i| \\leq 1 for all i, and |v_m| = 1 for at least one m.\n\nThe m-th row of R is:\n\n\\begin{bmatrix}\nr_{m,1} & r_{m,2} & \\cdots & r_{m,m-1} & 0 & r_{m,m+1} & \\cdots & r_{m,n}\n\\end{bmatrix}\n\nMultiplying this row by the vector \\mathbf{v}, the m-th entry of R \\mathbf{v} is:\n\n\\left( R \\mathbf{v} \\right)_m = \\sum_{i=1}^n r_{m,i} v_i\n\nSince r_{m,m} = 0 (as R = L + U excludes the diagonal), this simplifies to:\n\n\\left( R \\mathbf{v} \\right)_m = \\sum_{i=1, i \\neq m}^n r_{m,i} v_i\n\n\n\n\n\n\n\n\n\n\n3. Scaling with D:\n\n\n\nNow, explain why the absolute value of the m-th row of \\lambda D \\mathbf{v} is |\\lambda| |d_{m,m}|.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTo explain why the absolute value of the m-th row of \\lambda D \\mathbf{v} is |\\lambda| |d_{m,m}|, begin by recalling the structure of D, the diagonal matrix of A:\n\nD =\n\\begin{bmatrix}\nd_{1,1} & 0 & \\cdots & 0 \\\\\n0 & d_{2,2} & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & d_{n,n}\n\\end{bmatrix}\n\nWhen D is multiplied by the eigenvector \\mathbf{v}, the result is:\n\nD \\mathbf{v} =\n\\begin{bmatrix}\nd_{1,1} v_1 \\\\\nd_{2,2} v_2 \\\\\n\\vdots \\\\\nd_{n,n} v_n\n\\end{bmatrix}\n\nNow multiply by \\lambda, giving:\n\n\\lambda D \\mathbf{v} =\n\\begin{bmatrix}\n\\lambda d_{1,1} v_1 \\\\\n\\lambda d_{2,2} v_2 \\\\\n\\vdots \\\\\n\\lambda d_{n,n} v_n\n\\end{bmatrix}\n\nThe m-th row of this result is:\n\n\\left( \\lambda D \\mathbf{v} \\right)_m = \\lambda d_{m,m} v_m\n\nTaking the absolute value:\n\n\\left| \\left( \\lambda D \\mathbf{v} \\right)_m \\right| = |\\lambda| |d_{m,m}| |v_m|\n\nSince \\|\\mathbf{v}\\|_\\infty = 1, we know:\n\n|v_i| \\leq 1 \\quad \\text{for all } i, \\quad \\text{and} \\quad |v_m| = 1\n\nSubstitute |v_m| = 1:\n\n\\left| \\left( \\lambda D \\mathbf{v} \\right)_m \\right| = |\\lambda| |d_{m,m}|\n\nThus, the absolute value of the m-th row of \\lambda D \\mathbf{v} is determined by |\\lambda|, the eigenvalue, and |d_{m,m}|, the diagonal entry of D at row m.\n\n\n\n\n\n\n\n\n\nEQUATION 1\n\n\n\nCombining steps (2) and (3), we can write:\n\n|\\lambda||d_{m,m}| = |r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n|\n\n\n\n\n\n\n\n\n\n4. Explain why:\n\n\n\n\n|r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n| \\leq \\sum_{j \\neq m} |r_{m,j}|\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTo explain why\n\n\\big| r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n \\big| \\leq \\sum_{j \\neq m} |r_{m,j}|,\n\nwe begin by recalling the triangle inequality for absolute values. For any sum of terms a_1, a_2, \\dots, a_k, the triangle inequality ensures:\n\n|a_1 + a_2 + \\cdots + a_k| \\leq |a_1| + |a_2| + \\cdots + |a_k|\n\nIn our case, the sum of interest is:\n\nr_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n\n\nApplying the triangle inequality to this sum gives:\n\\quad \\big| r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n \\big|\n\n\\leq |r_{m,1}v_1| + |r_{m,2}v_2| + \\cdots + |r_{m,m-1}v_{m-1}| + |r_{m,m+1}v_{m+1}| + \\cdots + |r_{m,n}v_n|\n\nEach term in the sum has the form |r_{m,j}v_j|. Using the property of absolute values |ab| = |a||b|, we can rewrite each term as:\n\n|r_{m,j}v_j| = |r_{m,j}| \\cdot |v_j|\n\nSince it is assumed that |v_j| \\leq 1 for all j, it follows that:\n\n|r_{m,j}v_j| \\leq |r_{m,j}|\n\nSubstituting this bound for each term into the inequality gives:\n\\quad \\big| r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n \\big|\n\n\\leq |r_{m,1}v_1| + |r_{m,2}v_2| + \\cdots + |r_{m,m-1}v_{m-1}| + |r_{m,m+1}v_{m+1}| + \\cdots + |r_{m,n}v_n|\n\nThe indices j \\neq m correspond to all off-diagonal entries in the m-th row of the matrix. Thus, we can express the sum of the absolute values of the coefficients as:\n\n|r_{m,1}| + |r_{m,2}| + \\cdots + |r_{m,m-1}| + |r_{m,m+1}| + \\cdots + |r_{m,n}| = \\sum_{j \\neq m} |r_{m,j}|\n\nSubstituting this back, we find:\n\n\\big| r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n \\big| \\leq \\sum_{j \\neq m} |r_{m,j}|\n\nThe inequality holds because:\n\nThe triangle inequality ensures that the absolute value of a sum is at most the sum of the absolute values of its terms.\nThe assumption |v_j| \\leq 1 allows us to bound |r_{m,j}v_j| by |r_{m,j}|.\n\nThus, the magnitude of the weighted sum of v_j values (for j \\neq m) is always less than or equal to the sum of the absolute values of the off-diagonal entries in the m-th row of the matrix.\n\n\n\n\n\n\n\n\n\n5. Explain why:\n\n\n\n\n\\sum_{j \\neq m} |r_{m,j}| &lt; |d_{m,m}|\n\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nBy assumption, the matrix A is strictly diagonally dominant. This means that, for each row of A, the absolute value of the diagonal entry |d_{m,m}| is strictly greater than the sum of the absolute values of all the off-diagonal entries in that row:\n\n|d_{m,m}| &gt; \\sum_{j \\neq m} |r_{m,j}|\n\nIn other words, the diagonal entry d_{m,m} has the largest contribution in the row, ensuring that the total influence of the off-diagonal terms is strictly smaller.\n\n\n\n\n\n\n\n\n\n6. Use the results from Steps (4) and (5) with EQUATION 1 to show show that:\n\n\n\n\n|\\lambda||d_{m,m}| &lt; |d_{m,m}|\n\nWhat does this say about |\\lambda|?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nTo explain why\n\n|\\lambda||d_{m,m}| &lt; |d_{m,m}|\n\nwe combine the results from Step (4) and Step (5) with EQUATION 1.\nEQUATION 1 states:\n\n|\\lambda||d_{m,m}| = \\big| r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n \\big|\n\nFrom Step (4), we know:\n\n\\big| r_{m,1}v_1 + r_{m,2}v_2 + \\cdots + r_{m,m-1}v_{m-1} + r_{m,m+1}v_{m+1} + \\cdots + r_{m,n}v_n \\big| \\leq \\sum_{j \\neq m} |r_{m,j}|\n\nSubstituting this into EQUATION 1, we have:\n\n|\\lambda||d_{m,m}| \\leq \\sum_{j \\neq m} |r_{m,j}|\n\nFrom Step (5), we know:\n\n\\sum_{j \\neq m} |r_{m,j}| &lt; |d_{m,m}|\n\nCombining this with the inequality above gives:\n\n|\\lambda||d_{m,m}| &lt; |d_{m,m}|\n\nDividing both sides of the inequality by |d_{m,m}| (which is nonzero), we find:\n\n|\\lambda| &lt; 1\n\nThis result shows that the magnitude of the eigenvalue |\\lambda| is strictly less than 1 and this implies that the spectral radius \\rho(D^{-1}R) &lt; 1.\n\n\n\n\n\n\n\n\n\n7. Final Conclusion\n\n\n\nSince \\lambda is an arbitrary eigenvalue, then |\\lambda|_{\\text{max}} &lt; 1. In other words, the spectral radius \\rho(D^{-1}R) &lt; 1. Thus, by the Spectral Radius Convergence Theorem (Theorem A.7), the Jacobi Method (iteration with A = D^{-1}R) converges for any starting point \\mathbf{x}_0.\nLet \\mathbf{x}_* = \\lim_{k \\to \\infty} \\mathbf{x}_k, and show that \\mathbf{x}_* is the solution to A \\mathbf{x} = \\mathbf{b}, so A must be nonsingular. This completes the proof of the Diagonal Dominance Convergence Theorem (Theorem 2.10).\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nFrom earlier, we showed that the spectral radius \\rho(D^{-1}R), which is the largest magnitude of the eigenvalues of D^{-1}R, satisfies:\n\n\\rho(D^{-1}R) &lt; 1\n\nThis result guarantees that the Jacobi method converges to a solution \\mathbf{x}_* of A\\mathbf{x} = \\mathbf{b} for any starting point \\mathbf{x}_0, as stated in the Diagonal Dominance Convergence Theorem (Theorem A.7).\nTherefore, we can write the limit of the iterates \\mathbf{x}_k as:\n\n\\mathbf{x}_* = \\lim_{k \\to \\infty} \\mathbf{x}_k\n\nThe Jacobi iteration formula is:\n\n\\mathbf{x}_{k+1} = D^{-1}(\\mathbf{b} - R\\mathbf{x}_k)\n\nwhere A = D - R, D is the diagonal matrix, and R is the remainder matrix (containing the off-diagonal terms).\nSubstituting the limit \\mathbf{x}_* into this equation (as \\mathbf{x}_{k+1} \\to \\mathbf{x}_* and \\mathbf{x}_k \\to \\mathbf{x}_*), we get:\n\n\\mathbf{x}_* = D^{-1}(\\mathbf{b} - R\\mathbf{x}_*)\n\nExpanding this:\n\n\\mathbf{x}_* = -D^{-1}R\\mathbf{x}_* + D^{-1}\\mathbf{b}\n\nRewriting:\n\n\n\n\n\n\n‎\n\n\n\n\n\\mathbf{x}_* = -D^{-1}(L + U)\\mathbf{x}_* + D^{-1}\\mathbf{b}\n\n\n\nwhere R = L + U, with L being the strictly lower triangular part of A and U the strictly upper triangular part.\nTo verify \\mathbf{x}_* satisfies A\\mathbf{x}_* = \\mathbf{b}, substitute A = D + L + U into the system:\n\n(D + L + U)\\mathbf{x}_* = \\mathbf{b}\n\nMultiply both sides by D^{-1}:\n\n\\mathbf{x}_* + D^{-1}(L + U)\\mathbf{x}_* = D^{-1}\\mathbf{b}\n\nRearranging terms gives:\n\n\\mathbf{x}_* = -D^{-1}(L + U)\\mathbf{x}_* + D^{-1}\\mathbf{b}\n\nThis matches the Jacobi iteration formula, verifying \\mathbf{x}_* satisfies A\\mathbf{x}_* = \\mathbf{b}.\nConclusion\n\nWe proved that \\rho(D^{-1}R) &lt; 1, so the Jacobi method converges to \\mathbf{x}_*.\nSubstituting \\mathbf{x}_* into A\\mathbf{x} = \\mathbf{b}, we verified that it satisfies the system.\nSince A\\mathbf{x}_* = \\mathbf{b} has a solution, A is nonsingular."
  },
  {
    "objectID": "reality-checks/rc05/rc05.html",
    "href": "reality-checks/rc05/rc05.html",
    "title": "REALITY CHECK 05",
    "section": "",
    "text": "The use of Adaptive Quadrature is essential for maintaining constant speed along a specific path. This is a requirement in fields like computer-aided manufacturing, robotics and animation. Smooth and controlled movement is crucial for accuracy, but achieving a constant speed along a curved or complex path is challenging. Dividing a path into equal time intervals does not ensure equal-distance segments because the path’s shape influences the distance covered.\nTo address this, numerical methods are employed to divide the path into equal arc-length segments, ensuring consistent movement. The process involves several key steps:\n\nArc Length Measurement: The total length of the path is calculated using parametric equations, accounting for all curves and directional changes. This measurement provides the foundation for precise segmentation.\nMapping Path Position: To locate a point at a given distance s along the path, the corresponding parameter t is determined using numerical methods like Bisection or Newton’s Method. This ensures precise mapping of arc-length positions to their parametric coordinates.\nSegmenting the Path: The path is divided into segments of equal arc length, a process called equipartitioning. This segmentation ensures uniformity in the spacing of points along the path, regardless of its complexity or curvature.\nSmooth Traversal: Animations or simulations often demonstrate the practical effects of this approach. By comparing movement at constant parameter speed with movement along equal arc-length segments, the benefits of consistent, controlled traversal become clear, showcasing smoother and more predictable motion."
  },
  {
    "objectID": "reality-checks/rc05/rc05.html#path-equipartitioning-by-arc-length",
    "href": "reality-checks/rc05/rc05.html#path-equipartitioning-by-arc-length",
    "title": "REALITY CHECK 05",
    "section": "Path Equipartitioning by Arc Length",
    "text": "Path Equipartitioning by Arc Length\n\nProblem Statement\nEquipartition the path of Figure 5.6 into n subpaths of equal length, for n = 4 and n = 20. Plot analogues of Figure 5.6, showing the equipartitions.\n\n\n\n\n\n\n\n\n\n\n\nObjective and Approach\nThe objective is to partition the path, defined by parametric equations x(t) and y(t), into segments of equal arc length for a specified n. This method is valuable in fields requiring consistent movement along a path, such as animation or robotics.\nThe approach includes the following steps:\n\nCalculate Total Arc Length: Compute the total arc length from t = 0 to t = 1 using numerical integration, enabling calculation of the length of each segment.\n\n\\text{Segment length} = \\frac{\\text{Total arc length}}{n}\n\nLocate Partition Points Using the Bisection Method: For each segment i, use the Bisection Method to locate the parameter t_i so that the arc length from t = 0 to t = t_i equals i \\times \\text{Segment length}. This ensures equal arc lengths for each segment.\nPlot the Equipartitioned Path: Calculate x(t_i) and y(t_i) at each partition point and plot for both n = 4 and n = 20, visualizing uniform segmentation.\n\n\n\nSolution Code\n\n# Bisection method to find t for a target arc length fraction\ndef bisection_find_t(target_length, tol=1e-8):\n    a, b = 0, 1\n    while (b - a) / 2 &gt; tol:\n        midpoint = (a + b) / 2\n        if compute_arc_length(midpoint) == target_length:\n            return midpoint\n        elif compute_arc_length(midpoint) &lt; target_length:\n            a = midpoint\n        else:\n            b = midpoint\n    return (a + b) / 2\n\n# Equipartition function\ndef equipartition(n):\n    partition_points = [0]\n    total_length = compute_arc_length(1)\n    segment_length = total_length / n\n    for i in range(1, n):\n        target_length = i * segment_length\n        t_i = bisection_find_t(target_length)\n        partition_points.append(t_i)\n    partition_points.append(1)\n    return partition_points\n\n# Plot function for equipartitioned curve\ndef plot_styled_curve(n):\n    plt.figure(figsize=(8, 8), facecolor='white')\n\n    t_vals = np.linspace(0, 1, 500)\n    x_vals = x(t_vals)\n    y_vals = y(t_vals)\n\n    key_points_t = equipartition(n)\n    key_points_x = [x(t) for t in key_points_t]\n    key_points_y = [y(t) for t in key_points_t]\n\n    # Plot the curve with enhanced styling\n    plt.plot(x_vals, y_vals, color=\"#2196F3\", linewidth=2.5, zorder=3)\n    plt.scatter(key_points_x, key_points_y, color=\"#1565C0\", s=40, zorder=4)\n\n    # Add grid with softer appearance\n    plt.grid(True, linestyle='-', alpha=0.2, color='gray')\n    plt.xticks(np.arange(-1, 1.5, 0.5))\n    plt.yticks(np.arange(0, 2.5, 0.5))\n\n\n    # Enhanced axis lines\n    ax = plt.gca()\n    ax.set_xticklabels(['' if x == 0 else str(x) for x in ax.get_xticks()])\n    ax.set_yticklabels(['' if y == 0 else str(y) for y in ax.get_yticks()])\n\n    ax.spines['left'].set_position('zero')\n    ax.spines['bottom'].set_position('zero')\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['left'].set_linewidth(1.5)\n    ax.spines['bottom'].set_linewidth(1.5)\n\n    # Enhance tick appearance\n    plt.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')\n    plt.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')\n\n    # Label positioning and styling\n    ax.set_ylabel('y', rotation=0, labelpad=15, y=1.02, fontsize=12)\n    ax.set_xlabel('x', x=1.02, fontsize=12)\n\n    plt.xlim(-1.5, 1.5)\n    plt.ylim(-0.5, 2)\n    plt.gca().set_aspect('equal')\n\n    plt.show()\n\n\nEquipartitioned Curve with n = 4\n\n\n\n\n\n\n\n\n\n\n\nEquipartitioned Curve with n = 20\n\n\n\n\n\n\n\n\n\n\n\n\nExplanation of Solution Components\n\nArc Length Calculation: The function compute_arc_length(s) uses numerical integration to compute the arc length from t = 0 to a given t = s.\nBisection Method for Partitioning: bisection_find_t(target_length) finds the parameter t corresponding to a specific arc length, ensuring accurate partition points.\nEquipartition Function: equipartition(n) calculates t-values for partitioning the path into n equal arc-length segments.\nVisualization: plot_styled_curve(n) generates a plot showing the path with points marking each partition.\n\n\n\nResults and Observations\nThe plots for n = 4 and n = 20 illustrate the uniform segmentation of the path into equal-length segments, confirming the effectiveness of the equipartitioning process. This approach achieves constant distances along the path, despite non-uniform parameter spacing.\n\n\nConclusion\nThe solution effectively partitions the path into equal-length segments using numerical integration and the Bisection Method. This method can be further enhanced by employing Newton’s Method for faster convergence or adapting it to three-dimensional paths."
  },
  {
    "objectID": "reality-checks/rc05/rc05.html#path-equipartitioning-using-newtons-method",
    "href": "reality-checks/rc05/rc05.html#path-equipartitioning-using-newtons-method",
    "title": "REALITY CHECK 05",
    "section": "Path Equipartitioning Using Newton’s Method",
    "text": "Path Equipartitioning Using Newton’s Method\n\nProblem Statement\nReplace the Bisection Method in Step 2 with Newton’s Method, and repeat Steps 2 and 3. What is the derivative needed? What is a good choice for the initial guess? Is computation time decreased by this replacement?\n\n\nObjective and Approach\n\nObjective: Use Newton’s Method to locate each partition point t_i along the path, ensuring equal arc-length segments for a specified number of partitions n. Newton’s Method is expected to offer faster convergence than the Bisection Method, especially when starting with a good initial guess.\nRequired Derivative: Newton’s Method requires the derivative of the arc length function with respect to t, which is simply the arc length integrand evaluated at t:\n\nf'(t) = \\sqrt{\\left( \\frac{dx}{dt} \\right)^2 + \\left( \\frac{dy}{dt} \\right)^2}\n\nInitial Guess: A reasonable initial guess for each t_i is t_i = \\frac{i}{n}, which provides a uniformly spaced initial estimate along t, aiding the convergence of Newton’s Method.\nPerformance Comparison: To evaluate if Newton’s Method reduces computation time, we will measure the time taken by both the Bisection and Newton’s methods to achieve the same accuracy.\n\n\nWhy t_i = \\frac{i}{n} is a Good Initial Guess\n\nUniform Parameter Distribution: The parameter t varies between 0 and 1 (or the specified range of t), and \\frac{i}{n} provides evenly spaced points within this interval. This ensures that the initial guess is distributed consistently across the parameter space.\nProximity to the True Solution: For smooth and “well-behaved” curves, the true t_i values for equal arc-length segments are often near \\frac{i}{n}. This proximity ensures that Newton’s Method starts “in the ballpark” of the correct value.\nSimplicity and Efficiency: Computing \\frac{i}{n} is computationally trivial and requires no extra effort. This simplicity makes it a practical choice compared to complex initialization schemes.\nImproved Convergence: Starting close to the actual solution allows Newton’s Method to converge quadratically, reducing the number of iterations needed to achieve the desired accuracy.\n\n\n\n\nSolution Code\nThe following Python code implements Newton’s Method to find partition points and compares its performance with the Bisection Method.\n\nimport time\n\n# Newton's Method to find t for a target arc length\ndef newton_find_t(target_length, initial_guess, tol=1e-8, max_iter=100):\n    t = initial_guess\n    for _ in range(max_iter):\n        f_t = compute_arc_length(t) - target_length\n        f_prime_t = integrand(t)\n        if abs(f_t) &lt; tol:\n            return t\n        t -= f_t / f_prime_t  # Update t\n    return t\n\n# Compare performance of Bisection and Newton's methods\ndef compare_performance(target_length):\n    start_time_bisection = time.time()\n    bisection_result = bisection_find_t(target_length)\n    bisection_time = time.time() - start_time_bisection\n\n    start_time_newton = time.time()\n    newton_result = newton_find_t(target_length, initial_guess=0.5)\n    newton_time = time.time() - start_time_newton\n\n    print(f\"Bisection Method Result: {bisection_result:.9f} Time: {bisection_time:.9f} seconds\")\n    print(f\"Newton's Method Result: {newton_result:.9f} Time: {newton_time:.9f} seconds\")\n\n# Example target length (e.g., half the arc length)\ntotal_length = compute_arc_length(1)\ncompare_performance(total_length / 2)\n\nBisection Method Result: 0.800593771 Time: 0.003371000 seconds\nNewton's Method Result: 0.800593767 Time: 0.000715017 seconds\n\n\n\n\nExplanation of Solution Components\n\nNewton’s Method Implementation: The newton_find_t function applies Newton’s Method to locate the parameter t for a given arc length. It iteratively refines t by calculating f(t) and f'(t), adjusting t based on the result.\nPerformance Comparison: The compare_performance function compares the time taken by Bisection and Newton’s methods to find the target t-value. This illustrates the efficiency difference between the two methods.\n\n\n\nResults and Observations\n\nPerformance Gain: Newton’s Method generally converges faster than the Bisection Method due to its quadratic convergence rate.\nAccuracy: With an appropriately chosen initial guess, Newton’s Method efficiently reaches an accurate solution within fewer iterations.\n\n\n\nConclusion\nNewton’s Method provides a more efficient approach for finding the partition points, particularly when an initial guess is available. This reduction in computation time makes it suitable for tasks requiring high precision and quick convergence, such as real-time applications in path traversal and equipartitioning. Future explorations could involve further optimizations by dynamically refining initial guesses based on prior calculations."
  },
  {
    "objectID": "reality-checks/rc05/rc05.html#path-animation-at-original-and-constant-speed",
    "href": "reality-checks/rc05/rc05.html#path-animation-at-original-and-constant-speed",
    "title": "REALITY CHECK 05",
    "section": "Path Animation at Original and Constant Speed",
    "text": "Path Animation at Original and Constant Speed\n\nProblem Statement\nUse Python animation commands to demonstrate traveling along the path in two ways:\n\nAt the original speed, based on parameter t for 0 \\leq t \\leq 1, which results in non-uniform speed along the path.\nAt a constant speed using t^*(s) for 0 \\leq s \\leq 1, where the path is re-parameterized to maintain equal arc-length segments.\n\n\n\nObjective and Approach\n\nObjective: To visualize the difference between non-uniform and constant-speed traversal along a path.\n\nOriginal Speed: Animate movement along the path based on evenly spaced t-values, resulting in variable speed.\nConstant Speed: Animate movement along the path with equal arc-length segments by using equipartition points t^*(s).\n\nApproach:\n\nOriginal Speed Animation: Use uniformly spaced t-values from t = 0 to t = 1 to display the natural parameter-based speed.\nConstant Speed Animation: Use the previously calculated equipartition points t^*(s) to animate movement along equal arc-length segments, ensuring a uniform speed.\n\n\n\n\nSolution Code\nThe following Python code generates both animations, showing the path traversal at original and constant speeds.\nimport matplotlib.animation as animation\n\ndef animate_path():\n    fig = plt.figure(figsize=(16, 8), facecolor='white')\n\n    ax1 = fig.add_subplot(121)\n    ax2 = fig.add_subplot(122)\n\n    # Generate data for original and constant speed\n    t_values_original_speed = np.linspace(0, 1, 25)\n    x_vals_original_speed = x(t_values_original_speed)\n    y_vals_original_speed = y(t_values_original_speed)\n\n    t_values_constant_speed = equipartition(25)\n    x_vals_constant_speed = [x(t) for t in t_values_constant_speed]\n    y_vals_constant_speed = [y(t) for t in t_values_constant_speed]\n\n    # Enhanced styling function for subplots\n    def style_subplot(ax, title):\n        ax.grid(True, linestyle='-', alpha=0.2, color='gray')\n        ax.set_xlim(-1.5, 1.5)\n        ax.set_ylim(-0.5, 2)\n        ax.set_xticks(np.arange(-1, 1.5, 0.5))\n        ax.set_yticks(np.arange(0, 2.5, 0.5))\n        ax.set_aspect('equal')\n        ax.set_xticklabels(['' if x == 0 else str(x) for x in ax.get_xticks()])\n        ax.set_yticklabels(['' if y == 0 else str(y) for y in ax.get_yticks()])\n\n\n        # Enhanced axis lines\n        ax.spines['left'].set_position('zero')\n        ax.spines['bottom'].set_position('zero')\n        ax.spines['right'].set_visible(False)\n        ax.spines['top'].set_visible(False)\n        ax.spines['left'].set_linewidth(1.5)\n        ax.spines['bottom'].set_linewidth(1.5)\n\n        # Enhanced ticks\n        ax.tick_params(axis='both', which='major', length=6, width=1, colors='black', direction='out')\n        ax.tick_params(axis='both', which='minor', length=3, width=1, colors='black', direction='out')\n\n        ax.set_title(title, pad=20, fontsize=12, fontweight='bold')\n\n    # Configure first subplot\n    ax1.plot(x_vals_original_speed, y_vals_original_speed, color=\"#2196F3\", linewidth=2.5, zorder=3)\n    original_point, = ax1.plot([], [], 'o', color=\"#1565C0\", markersize=8, zorder=4)\n    style_subplot(ax1, \"Original Speed\")\n\n    # Configure second subplot\n    ax2.plot(x_vals_constant_speed, y_vals_constant_speed, color=\"#2196F3\", linewidth=2.5, zorder=3)\n    constant_point, = ax2.plot([], [], 'go',  markersize=8, zorder=4)\n    style_subplot(ax2, \"Constant Speed\")\n\n    plt.tight_layout()\n\n    def update_original(fnum):\n        original_point.set_data(x_vals_original_speed[:fnum], y_vals_original_speed[:fnum])\n        return original_point,\n\n    def update_constant(fnum):\n        constant_point.set_data(x_vals_constant_speed[:fnum], y_vals_constant_speed[:fnum])\n        return constant_point,\n\n    num_frames = len(x_vals_original_speed)\n    ani = animation.FuncAnimation(fig, lambda fnum: update_original(fnum) + update_constant(fnum),\n                                frames=num_frames, interval=200, blit=True)\n    ani.save('combined_animation.mp4', writer='ffmpeg')\n\n  Your browser does not support the video tag. \n\n\n\nExplanation of Solution Components\n\nAnimation Setup:\n\nOriginal Speed: Uses evenly spaced t-values from 0 to 1, resulting in non-uniform movement along the path.\nConstant Speed: Uses equipartition points t^*(s), calculated to ensure each segment has the same arc length, resulting in uniform movement.\n\nAnimation Update Functions: Each animation frame updates the moving point on the respective path for both original and constant speeds.\n\n\n\nResults and Observations\nThe two animations effectively demonstrate the difference between moving at a variable speed (based on t) and moving at a constant speed along equal arc-length segments. By using equipartition points, the constant-speed animation shows smooth, uniform movement, which can be advantageous for applications requiring consistent traversal rates."
  },
  {
    "objectID": "reality-checks/rc05/rc05.html#experimenting-with-equipartitioning-on-a-custom-path",
    "href": "reality-checks/rc05/rc05.html#experimenting-with-equipartitioning-on-a-custom-path",
    "title": "REALITY CHECK 05",
    "section": "Experimenting with Equipartitioning on a Custom Path",
    "text": "Experimenting with Equipartitioning on a Custom Path\n\nProblem Statement\nExperiment with equipartitioning a path of your choice. Choose a path defined by parametric equations, partition it into equal arc-length segments, and animate the traversal as demonstrated in Problem 5.\n\nChosen Equation:\n\nx(t) = 0.4 \\sin(3t + \\frac{\\pi}{2}) + 0.5\n\n\ny(t) = 0.3 \\sin(4t) + 0.5\n\n\n\n\nObjective and Approach\n\nObjective: To apply equipartitioning to the specified path, dividing it into segments of equal arc length and visualizing the traversal at constant speed.\nApproach:\n\nPath Definition: Define x(t) and y(t) based on the given equations.\nEquipartitioning: Use numerical integration and Newton’s Method to divide the path into equal-length segments.\nAnimation: Animate the traversal of the path at a constant speed along the equal arc-length segments and compare it with traversal at the original, parameter-based speed.\n\n\n\n\nSolution Code\nThe Python code below calculates the equipartitioned segments and animates traversal along the path:\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nfrom scipy.integrate import quad\n\n# Parameters for the curve\nA = 0.4\na = 3\nf = np.pi / 2\nc = 0.5\nB = 0.3\nb = 4\nD = 0.5\n\n# Maximum value of t for one full loop\nt_max = 2 * np.pi\n\n# Define the functions for x(t) and y(t)\ndef x(t):\n    return A * np.sin(a * t + f) + c\n\ndef y(t):\n    return B * np.sin(b * t) + D\n\n# Derivatives of x(t) and y(t) for arc length calculation\ndef dx_dt(t):\n    return A * a * np.cos(a * t + f)\n\ndef dy_dt(t):\n    return B * b * np.cos(b * t)\n\n# Integrand for arc length calculation\ndef integrand(t):\n    return np.sqrt(dx_dt(t)**2 + dy_dt(t)**2)\n\n# Compute arc length using numerical integration\ndef compute_arc_length(s):\n    arc_length, _ = quad(integrand, 0, s)\n    return arc_length\n\n# Equipartition function to divide path into equal arc-length segments\ndef equipartition(n):\n    total_length = compute_arc_length(2 * np.pi)\n    segment_length = total_length / n\n    partition_points = [0]\n    for i in range(1, n):\n        target_length = i * segment_length\n        partition_points.append(find_t_for_length(target_length, partition_points[-1]))\n    partition_points.append(2 * np.pi)\n    return partition_points\n\n# Find parameter t for a given arc length using Newton's Method\ndef find_t_for_length(target_length, initial_guess=0, tol=1e-8, max_iter=100):\n    t = initial_guess\n    for _ in range(max_iter):\n        f_t = compute_arc_length(t) - target_length\n        f_prime_t = integrand(t)\n        if abs(f_t) &lt; tol:\n            return t\n        t -= f_t / f_prime_t\n        t = max(0, min(2 * np.pi, t))\n    return t\n\n\n# Data for animations\nn_points = 200\nt_values_original = np.linspace(0, 2 * np.pi, n_points)\nx_original = x(t_values_original)\ny_original = y(t_values_original)\n\nt_values_constant = equipartition(n_points)\nx_constant = [x(t) for t in t_values_constant]\ny_constant = [y(t) for t in t_values_constant]\n\n# Set up the figure for side-by-side animation\nfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 6))\n\n# Original speed plot\nax1.plot(x_original, y_original, color=\"#2196F3\", linewidth=2)\npoint1, = ax1.plot([], [], 'o', color=\"#1565C0\")\nax1.set_title(\"Original Speed\")\nax1.set_xlim(0, 1)\nax1.set_ylim(0, 1)\nax1.set_aspect('equal')\nax1.grid(True, linestyle='-', alpha=0.2, color='gray')\n\n# Constant speed plot\nax2.plot(x_constant, y_constant, color=\"#2196F3\", linewidth=2)\npoint2, = ax2.plot([], [], 'go')\nax2.set_title(\"Constant Speed\")\nax2.set_xlim(0, 1)\nax2.set_ylim(0, 1)\nax2.set_aspect('equal')\nax2.grid(True, linestyle='-', alpha=0.2, color='gray')\n\n# Update functions for each animation\ndef update_original(frame):\n    point1.set_data(x_original[:frame], y_original[:frame])\n    return point1,\n\ndef update_constant(frame):\n    point2.set_data(x_constant[:frame], y_constant[:frame])\n    return point2,\n\n# Combine animations into one\nnum_frames = len(x_original)\nani = animation.FuncAnimation(\n    fig,\n    lambda frame: update_original(frame) + update_constant(frame),\n    frames=num_frames,\n    interval=100,\n    blit=True\n)\n\n# Save animation as MP4\nani.save(\"custom_path_animation.mp4\", writer=\"ffmpeg\")\n\n  Your browser does not support the video tag. \n\n\n\nExplanation of Solution Components\n\nPath Definition: The parametric equations for x(t) = 0.4 \\sin(3t + \\frac{\\pi}{2}) + 0.5 and y(t) = 0.3 \\sin(4t) + 0.5 define a periodic curve with sinusoidal behavior, creating a visually interesting pattern with symmetric, tight curves.\nArc Length Calculation: The function compute_arc_length integrates the instantaneous speed along the curve (using derivatives dx/dt and dy/dt) over the interval [0, s] to determine the total distance traveled up to a given s.\nEquipartitioning: The equipartition function divides the path into n segments of equal arc length by calculating the target length of each segment and using Newton’s Method to determine t values corresponding to each target segment length. This ensures the segments are evenly spaced along the curve.\nAnimation: The animate_path function generates side-by-side animations of path traversal at original speed (based on parameter t) and constant speed (based on equal arc-length segments).\n\n\n\nResults and Observations\nIn the animation:\n\nOriginal Speed: The left animation shows traversal based on equally spaced t values, resulting in variable speed along the curve. The point moves faster along straighter sections and slows down significantly in tighter curves.\nConstant Speed: The right animation demonstrates traversal at a constant speed along equal arc-length segments. This movement is smoother and consistent, highlighting how equipartitioning ensures a steady traversal rate even along complex paths.\n\n\n\nConclusion\nThis exercise illustrates the benefits of equipartitioning a path into equal arc-length segments for applications that require consistent speed. By reparameterizing the curve to maintain constant speed, we can avoid the variable movement speed that results from a simple, evenly spaced parameter t. This method has potential applications in animation, robotics, and automated manufacturing, where uniform movement along a path with varying curvature is essential."
  },
  {
    "objectID": "practice-exams/exam2/practice-exam2-part-1.html",
    "href": "practice-exams/exam2/practice-exam2-part-1.html",
    "title": "PRACTICE EXAM 2 PART 1",
    "section": "",
    "text": "Direct Solving via Gaussian Elimination / PA=LU Factorization\n(a) Gaussian Elimination\nSolve the following system of equations using Gaussian elimination:\n\\[\n\\begin{cases}\n2x + y - z = 8 \\\\\n-3x - y + 2z = -11 \\\\\n-2x + y + 2z = -3 \\\\\n\\end{cases}\n\\]\n(b) PA=LU Factorization\nPerform a PA=LU factorization of the following matrix \\(A\\):\n\\[\nA = \\begin{pmatrix}\n0 & 2 & 1 \\\\\n1 & -2 & -1 \\\\\n-1 & 0 & 2 \\\\\n\\end{pmatrix}\n\\]\nFind the permutation matrix \\(P\\), lower triangular matrix \\(L\\), and upper triangular matrix \\(U\\) such that \\(PA = LU\\).\n\n\nIterative Methods\n(a) Convergence of Iterative Methods\nConsider the matrix \\(A\\):\n\\[\nA = \\begin{pmatrix}\n5 & -2 & 3 \\\\\n-3 & 9 & 1 \\\\\n2 & -1 & -7 \\\\\n\\end{pmatrix}\n\\]\nIs the Jacobi iterative method guaranteed to converge for the system \\(A\\mathbf{x} = \\mathbf{b}\\) for any \\(\\mathbf{b}\\)? Justify your answer.\n(b) Theorem Application\nExplain how the spectral radius of the iteration matrix affects the convergence of an iterative method. Refer to the theorem stating that if the spectral radius is less than 1, the method converges.\n\n\nJacobi and Gauss-Seidel Methods\n(a) Jacobi Method\nFor the following system:\n\\[\n\\begin{cases}\n10x_1 - x_2 + 2x_3 = 6 \\\\\n-x_1 + 11x_2 - x_3 + 3x_4 = 25 \\\\\n2x_1 - x_2 + 10x_3 - x_4 = -11 \\\\\n3x_2 - x_3 + 8x_4 = 15 \\\\\n\\end{cases}\n\\]\nPerform two iterations of the Jacobi method starting with \\(\\mathbf{x}^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\end{pmatrix}\\).\n(b) Gauss-Seidel Method\nPerform two iterations of the Gauss-Seidel method for the same system and initial guess.\n\n\nLeast Squares and Orthogonalizations\n(a) Normal Equations\nGiven the overdetermined system:\n\\[\n\\begin{cases}\nx + y = 2 \\\\\n2x + y = 3 \\\\\nx + 2y = 3 \\\\\n\\end{cases}\n\\]\nFind the least squares solution by setting up and solving the normal equations.\n(b) QR Factorization\nUsing the same system, perform the QR factorization of the matrix \\(A\\) (the coefficient matrix) using the Gram-Schmidt process (either classical or modified). Then, solve \\(R\\mathbf{x} = Q^\\top\\mathbf{b}\\) by back substitution.\n\n\nGram-Schmidt Process\nApply the Gram-Schmidt process to the following set of vectors to obtain an orthonormal basis for \\(\\mathbb{R}^3\\):\n\\[\n\\mathbf{v}_1 = \\begin{pmatrix} 1 \\\\ 1 \\\\ 0 \\end{pmatrix}, \\quad\n\\mathbf{v}_2 = \\begin{pmatrix} 1 \\\\ 0 \\\\ 1 \\end{pmatrix}, \\quad\n\\mathbf{v}_3 = \\begin{pmatrix} 0 \\\\ 1 \\\\ 1 \\end{pmatrix}\n\\]\nCompute the QR factorization \\(A = QR\\) where \\(A\\) has columns \\(\\mathbf{v}_1, \\mathbf{v}_2, \\mathbf{v}_3\\).\n\n\nSolving \\(R\\mathbf{x} = Q^\\top\\mathbf{b}\\) by Back Substitution\nGiven the QR factorization from Question 5, and a vector \\(\\mathbf{b} = \\begin{pmatrix} 2 \\\\ 3 \\\\ 4 \\end{pmatrix}\\), solve \\(R\\mathbf{x} = Q^\\top\\mathbf{b}\\) for \\(\\mathbf{x}\\) using back substitution.\n\n\nGMRES with Preconditioning\n(a) Conceptual Understanding\nExplain the role of preconditioning in the GMRES (Generalized Minimal Residual) method and how it improves convergence when solving non-symmetric linear systems.\n(b) Computational Exercise\nGiven the matrix \\(A\\) and vector \\(\\mathbf{b}\\):\n\\[\nA = \\begin{pmatrix}\n4 & 1 \\\\\n2 & 3 \\\\\n\\end{pmatrix}, \\quad\n\\mathbf{b} = \\begin{pmatrix}\n1 \\\\\n0 \\\\\n\\end{pmatrix}\n\\]\nSuppose we use a preconditioner \\(M\\) such that \\(M^{-1}A\\) has better spectral properties. Let\n\\[\nM = \\begin{pmatrix}\n4 & 0 \\\\\n0 & 3 \\\\\n\\end{pmatrix}.\n\\]\nPerform one iteration of the preconditioned GMRES algorithm starting from \\(\\mathbf{x}_0 = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}\\)."
  },
  {
    "objectID": "reality-checks/rc01/rc01.html",
    "href": "reality-checks/rc01/rc01.html",
    "title": "REALITY CHECK 01",
    "section": "",
    "text": "PROBLEM 1\n\n\nWrite a python function for f(\\theta). The parameters L_1, L_2, L_3, \\gamma, x_1, x_2, y_2 are fixed constants, and the strut lengths p_1, p_2, p_3 will be known for a given pose. To test your code, set the parameters L_1 = 2, L_2 = L_3 = \\sqrt{2}, \\gamma = \\pi/2, and p_1 = p_2 = p_3 = \\sqrt{5}. Then, substituting \\theta = -\\pi/4 or \\theta = \\pi/4, should make f(\\theta) = 0.\nI implemented the Python function f(\\theta) by putting all fixed constants into a Constants object. I initialized the constants with the given values in order to verify that \\theta = -\\pi/4 and \\theta = \\pi/4 were roots.\n\n\nCreate function for f(\\theta)\n\n\nShow Code\n# Define the function f(θ) that calculates based on given constants and angle θ\ndef f(theta, constants):\n    \"\"\"\n    Calculates a value based on the given angle theta and constants object.\n\n    Parameters:\n    theta (float): The angle in radians.\n    constants (Constants): An object containing the necessary constants.\n\n    Returns:\n    float: The calculated result.\n    \"\"\"\n    l1, l2, l3 = constants.l1, constants.l2, constants.l3\n    gamma = constants.gamma\n    x1, x2, y2 = constants.x1, constants.x2, constants.y2\n    p1, p2, p3 = constants.p1, constants.p2, constants.p3\n\n    a2 = l3 * np.cos(theta) - x1\n    b2 = l3 * np.sin(theta)\n    a3 = l2 * np.cos(theta + gamma) - x2\n    b3 = l2 * np.sin(theta + gamma) - y2\n    d = 2 * (a2 * b3 - b2 * a3)\n\n    n1 = b3 * (p2**2 - p1**2 - a2**2 - b2**2) - b2 * (p3**2 - p1**2 - a3**2 - b3**2)\n    n2 = -a3 * (p2**2 - p1**2 - a2**2 - b2**2) + a2 * (p3**2 - p1**2 - a3**2 - b3**2)\n\n    return n1**2 + n2**2 - p1**2 * d**2\n\n\n\n\nTest function f(\\theta)\n\n\nShow Code\n# Define constants and evaluate f(θ) at a specific angle θ = π/4 for testing purposes\nconstants = Constants(\n    l1=2,\n    l2=np.sqrt(2),\n    l3=np.sqrt(2),\n    gamma=np.pi / 2,\n    x1=4,\n    x2=0,\n    y2=4,\n    p1=np.sqrt(5),\n    p2=np.sqrt(5),\n    p3=np.sqrt(5)\n)\n\ntheta = np.pi / 4\n# Evaluate\nresult = f(theta, constants)\nprint(f'f(θ=π/4) = {result}')\n\n\nf(θ=π/4) = -4.547473508864641e-13\n\n\n\n\n\nPROBLEM 2\n\n\nPlot f(\\theta) on [-\\pi, \\pi]\nI plotted the function f(\\theta) over the interval [-π, π] by generating a range of \\theta values and computing f(\\theta) for each. The graph clearly shows the behavior of f(\\theta) and highlights that the the roots identified in Problem 1 are in fact roots.\n\n\nCreate Plot\n\n\nShow Code\n# Generate a range of theta values and compute f(θ) for each value to visualize the function\ntheta_values = np.linspace(-np.pi, np.pi, 400)\nresults = [f(theta, constants) for theta in theta_values]\n\n# Plot f(θ) over the range of theta values\nplt.figure(figsize=(10, 6))\nplt.plot(theta_values, results, label=r'$f(\\theta)$', linewidth=2)\nplt.axhline(0, color='black', linestyle='--', linewidth=0.8)\nplt.axvline(-np.pi/4, color='red', linestyle=':', linewidth=2, label=r'$\\theta = -\\pi/4$')\nplt.axvline(np.pi/4, color='red', linestyle=':', linewidth=2, label=r'$\\theta = \\pi/4$')\nplt.xlabel(r'$\\theta$', fontsize=14)\nplt.ylabel(r'$f(\\theta)$', fontsize=14)\nplt.title(r'Function of $\\theta$ for Stewart Platform', fontsize=16)\nplt.legend(fontsize=12)\nplt.grid(True)\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nPROBLEM 3\n\n\nReproduce Figure 1.15. Plot a red triangle with vertices (u_1, v_1), (u_2, v_2), (u_3, v_3) and place small blue circles at the strut anchor points (0,0), (x_1, 0), (x_2, y_2):\nI utilized several helper functions to efficiently calculate and visualize the Stewart platform’s configuration. The get_x_y() function computes the x and y coordinates based on the given angle \\theta and the fixed constants, determining the position of one vertex of the triangle. The get_points() function then takes these coordinates, along with \\theta and the constants, to calculate the two other vertices of the red triangle. The get_anchor_points() function gets the fixed anchor points (0,0), (x_1, 0), and (x_2, y_2). The plot_triangle() function takes the calculated triangle vertices and anchor points to plot the red triangle and connect the anchor points with blue lines, while also marking the anchor points with blue circles.\n\n\nCreate Helper Functions\n\n\nShow Code\n# Define helper functions for calculating x, y coordinates and plotting the Stewart platform triangle\ndef get_x_y(theta, constants):\n    \"\"\"\n    Returns the coordinates x and y for the given angle theta and constants object.\n\n    Parameters:\n    theta (float): The angle in radians.\n    constants (Constants): An object containing the necessary constants.\n\n    Returns:\n    tuple: The coordinates (x, y).\n    \"\"\"\n    l1, l2, l3 = constants.l1, constants.l2, constants.l3\n    gamma = constants.gamma\n    x1, x2, y2 = constants.x1, constants.x2, constants.y2\n    p1, p2, p3 = constants.p1, constants.p2, constants.p3\n\n    a2 = l3 * np.cos(theta) - x1\n    b2 = l3 * np.sin(theta)\n    a3 = l2 * np.cos(theta + gamma) - x2\n    b3 = l2 * np.sin(theta + gamma) - y2\n\n    d = 2 * (a2 * b3 - b2 * a3)\n    n1 = b3 * (p2**2 - p1**2 - a2**2 - b2**2) - b2 * (p3**2 - p1**2 - a3**2 - b3**2)\n    n2 = -a3 * (p2**2 - p1**2 - a2**2 - b2**2) + a2 * (p3**2 - p1**2 - a3**2 - b3**2)\n\n    x = n1 / d\n    y = n2 / d\n\n    return x, y\n\n\ndef get_points(x, y, theta, constants):\n    \"\"\"\n    Calculate the three points (vertices) of the triangle in the Stewart platform based on x, y, and θ.\n\n    Parameters:\n    x (float): The x-coordinate.\n    y (float): The y-coordinate.\n    theta (float): The angle in radians.\n    constants (Constants): Object containing the necessary constants.\n\n    Returns:\n    list: A list containing the three vertices (l1_point, l2_point, l3_point) of the triangle.\n    \"\"\"\n    l1, l2, l3 = constants.l1, constants.l2, constants.l3\n    gamma = constants.gamma\n\n    # First vertex (base point)\n    l1_point = (x, y)\n\n    # Second vertex of the triangle\n    l2_x = x + (l3 * np.cos(theta))\n    l2_y = y + (l3 * np.sin(theta))\n    l2_point = (np.round(l2_x, 3), np.round(l2_y))  # Rounded to 3 decimal places for clarity\n\n    # Third vertex of the triangle\n    l3_x = x + (l2 * np.cos(theta + gamma))\n    l3_y = y + (l2 * np.sin(theta + gamma))\n    l3_point = (np.round(l3_x), np.round(l3_y))  # Rounded to 3 decimal places for clarity\n\n    return [l1_point, l2_point, l3_point]\n\ndef get_anchor_points(constants):\n    \"\"\"\n    Get the anchor points for the Stewart platform based on the constants.\n\n    Parameters:\n    constants (Constants): Object containing the necessary constants.\n\n    Returns:\n    list: A list of tuples representing the anchor points.\n    \"\"\"\n    x1, x2, y2 = constants.x1, constants.x2, constants.y2\n\n    return [(0, 0), (x1, 0), (x2, y2)]\n\ndef plot_triangle(ax, points, anchor_points, x_limits=None, y_limits=None, x_step=None, y_step=None):\n    \"\"\"\n    Plots a triangle given the points and anchor points on the provided axis.\n\n    Parameters:\n    ax: The axis on which to plot the triangle.\n    points: The points of the triangle (list of 3 points).\n    anchor_points: The anchor points (list of 2 or more points).\n    x_limits (tuple, optional): Tuple specifying the x-axis limits (x_min, x_max).\n    y_limits (tuple, optional): Tuple specifying the y-axis limits (y_min, y_max).\n    x_step (float, optional): Step size for the x-axis grid.\n    y_step (float, optional): Step size for the y-axis grid.\n\n    Returns:\n    None\n    \"\"\"\n    points = np.array(points)\n    anchor_points = np.array(anchor_points)\n\n    # Extract x and y coordinates for the triangle points\n    x_coords = points[:, 0]\n    y_coords = points[:, 1]\n\n    # Close the triangle by appending the first point at the end\n    x_closed = np.append(x_coords, x_coords[0])\n    y_closed = np.append(y_coords, y_coords[0])\n\n    # Plot the triangle with red lines\n    ax.plot(x_closed, y_closed, 'r-', linewidth=3.5)\n\n    # Plot blue dots at the triangle vertices\n    ax.plot(x_coords, y_coords, 'bo', markersize=8)\n\n    # Plot lines from anchor points to triangle points\n    for i, anchor in enumerate(anchor_points):\n        if i &lt; len(points):  # Ensure we stay within bounds\n            ax.plot([anchor[0], points[i, 0]], [anchor[1], points[i, 1]], 'b-', linewidth=1.5)\n\n    # Plot blue dots at the anchor points\n    ax.plot(anchor_points[:, 0], anchor_points[:, 1], 'bo', markersize=8)\n\n    # Set axis labels\n    ax.set_xlabel(\"x\")\n    ax.set_ylabel(\"y\")\n\n    # Set x-axis limits if provided\n    if x_limits is not None:\n        ax.set_xlim(x_limits)\n    # Set y-axis limits if provided\n    if y_limits is not None:\n        ax.set_ylim(y_limits)\n    # Set grid step increments if limits are provided\n    if x_step is not None and x_limits is not None:\n        ax.set_xticks(np.arange(x_limits[0], x_limits[1] + x_step, x_step))  # Adjust x-axis ticks\n    if y_step is not None and y_limits is not None:\n        ax.set_yticks(np.arange(y_limits[0], y_limits[1] + y_step, y_step))  # Adjust y-axis ticks\n\n    # Add grid for better visualization\n    ax.grid(True)\n\n\n\n\nCreate Plot\n\n\nShow code\n# Create a plot to visualize the Stewart platform configurations for two different angles\ntheta = np.pi / 4\ntheta_negative = -np.pi / 4\n\n# Calculate the coordinates and points for the triangles\nx, y = get_x_y(theta_negative, constants)\npoints1 = get_points(x, y, theta_negative, constants)\nanchor_points = get_anchor_points(constants)\n\nx, y = get_x_y(theta, constants)\npoints2 = get_points(x, y, theta, constants)\n\n# Create side-by-side subplots to visualize the two triangles\nfig, axes = plt.subplots(1, 2, figsize=(10, 5))\n\n# Plot the triangles on each subplot\nplot_triangle(axes[0], points1, anchor_points, x_limits=(-0.25, 4.25), y_limits=(-0.25, 4.25))\nplot_triangle(axes[1], points2, anchor_points, x_limits=(-0.25, 4.25), y_limits=(-0.25, 4.25))\n\nplt.tight_layout()\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\nPROBLEM 4\n\n\nSolve the forward kinematics problem for the planar Stewart platform specified by x_1 = 5, (x_2, y_2) = (0,6), L_1 = L_3 = 3, L_2 = 3\\sqrt{2}, \\gamma = \\pi / 4, p_1 = p_2 = 5, p_3 = 3. Begin by plotting f(\\theta). Use an equation solver of your choice to find all four poses (roots of f(\\theta)), and plot them. Check your answers by verifying that p_1, p_2, p_3 are the lengths of the struts in your plot.\nI organized all the fixed parameters into a Constants object and plotted the function f(\\theta) over the interval [-π, π] to visualize its behavior. Using the fsolve function with strategically chosen initial guesses, I identified all four roots of f(\\theta), each root representing a unique pose of the Stewart platform. For each detected root, I plotted the corresponding triangle configuration and verified that the strut lengths p_1, p_2, p_3 matched the expected values.\n\n\n4A)\n\n\nShow Code\n# Create new constants object\nconstants = Constants(\n    l1=3,\n    l2=3 * np.sqrt(2),\n    l3=3,\n    gamma=np.pi / 4,\n    x1=5,\n    x2=0,\n    y2=6,\n    p1=5,\n    p2=5,\n    p3=3\n)\n\n# Generate an array of θ values between -π and π\ntheta_values = np.linspace(-np.pi, np.pi, 400)\n\n# Plot the function f(θ) over the range of θ values using the given constants\nplt.figure(figsize=(10, 6))\nplt.plot(theta_values, f(theta_values, constants), label=r'$f(\\theta)$')\nplt.axhline(0, color='black', linestyle='--', linewidth=0.8)\nplt.xlabel(r'$\\theta$', fontsize=14)\nplt.ylabel(r'$f(\\theta)$', fontsize=14)\nplt.title(r'Function of $\\theta$ for Stewart Platform', fontsize=16)\nplt.legend(fontsize=12)\nplt.grid(True)\n\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n4B)\n\n\nShow Code\n# Function to find roots of f(θ) using fsolve\ndef find_roots(constants, initial_guesses):\n    \"\"\"\n    Finds roots of f(θ) using different initial guesses and the fsolve method.\n\n    Parameters:\n    constants (Constants): Object containing the necessary constants.\n    initial_guesses (list or array): List of initial guesses for fsolve to start from.\n\n    Returns:\n    list: A list of unique roots.\n    \"\"\"\n\n    # Create an empty list to store the roots found\n    roots = []\n    # Iterate over each initial guess and find the root using fsolve\n    for guess in initial_guesses:\n        root = fsolve(f, guess, args=(constants), xtol=1e-12)[0] # Find root for each guess\n        roots.append(root) # Append the found root to the list\n\n    # Return only unique roots to avoid duplicates\n    unique_roots = np.unique(roots)\n    return unique_roots\n\n# Define initial guesses for fsolve to start the root-finding process\ninitial_guesses = [- 1, np.pi / 3, .5, 2]\n\n# Find and print the roots using the initial guesses\nroots = find_roots(constants, initial_guesses)\nprint(f\"The roots of f(θ) in the interval are : {roots}\")\n\n# Function to calculate the length of the struts\ndef calculate_strut_lengths(points, anchor_points):\n    lengths = []\n    # Loop through the 3 points and calculate the Euclidean distance to each corresponding anchor point\n    for i in range(3):\n        length = np.sqrt((points[i][0] - anchor_points[i][0])**2 + (points[i][1] - anchor_points[i][1])**2)\n        lengths.append(length) # Append each calculated length to the list\n    return lengths\n\n\nThe roots of f(θ) in the interval are : [-0.7208492  -0.33100518  1.14368552  2.11590901]\n\n\n\n\nShow Code\n# Create a 2x2 grid of subplots to visualize the four roots and their corresponding triangles\nfig, axes = plt.subplots(2, 2, figsize=(10, 10))\naxes = axes.flatten() # Flatten the 2D array of subplots into a 1D array for easier access\n\n# Get the anchor points for the Stewart platform\nanchor_points = get_anchor_points(constants)\n\n# Loop through up to four roots and plot the corresponding triangles\nfor i, theta in enumerate(roots[:4]):\n    x, y = get_x_y(theta, constants)\n    points = get_points(x, y, theta, constants)\n\n    # Plot the triangle in the corresponding subplot with custom limits\n    plot_triangle(axes[i], points, anchor_points, x_limits=(-2.5, 7.5), y_limits=(-2, 7), x_step=2.5, y_step=2)\n    axes[i].set_title(rf\"$\\theta$ = {theta}\")\n\n    # Calculate and verify strut lengths\n    lengths = calculate_strut_lengths(points, anchor_points)\n    print(f\"For root {np.round(theta, 3)}, strut lengths are: {np.round(lengths)}\")\n    print(f\"Expected: p1={constants.p1}, p2={constants.p2}, p3={constants.p3}\\n\")\n\n# Turn off any unused subplots if fewer than four roots\nfor j in range(len(roots), 4):\n    axes[j].axis('off')\n\n# Adjust layout\nplt.tight_layout()\n\nplt.show()\n\n\nFor root -0.721, strut lengths are: [5. 5. 3.]\nExpected: p1=5, p2=5, p3=3\n\nFor root -0.331, strut lengths are: [5. 5. 3.]\nExpected: p1=5, p2=5, p3=3\n\nFor root 1.144, strut lengths are: [5. 5. 3.]\nExpected: p1=5, p2=5, p3=3\n\nFor root 2.116, strut lengths are: [5. 5. 3.]\nExpected: p1=5, p2=5, p3=3\n\n\n\n\n\n\n\n\n\n\n\n\n\nPROBLEM 5\n\n\nChange strut length to p_2 = 7 and re-solve the problem. For these parameters, there are six poses.\nI updated the strut length p_2 to 7 and re-solved the forward kinematics for the Stewart platform. To do that I modified the Constants object with the new p_2 value and plotted the updated function f(\\theta) over the interval [-π, π] to see its behavior. I made a new set of initial guesses for the find_roots() function and successfully found all six roots corresponding to six possible poses. For each root, I plotted the corresponding triangle configuration and verified that the strut lengths p_1, p_2, p_3 matched the expected values.\n\n\n5A)\n\n\nShow Code\n# Update the constants to reflect the new strut length p2 = 7\nconstants = Constants(\n    l1=3,\n    l2=3 * np.sqrt(2),\n    l3=3,\n    gamma=np.pi / 4,\n    x1=5,\n    x2=0,\n    y2=6,\n    p1=5,\n    p2=7,\n    p3=3\n)\n\n# Generate the θ values again to visualize the updated f(θ)\ntheta_values = np.linspace(-np.pi, np.pi, 400)\n\n# Plot f(θ) for the new strut length\nplt.figure(figsize=(10, 6))\nplt.plot(theta_values, f(theta_values, constants), label=r'$f(\\theta)$')\nplt.axhline(0, color='black', linestyle='--', linewidth=0.8)\nplt.xlabel(r'$\\theta$', fontsize=14)\nplt.ylabel(r'$f(\\theta)$', fontsize=14)\nplt.title(r'Function of $\\theta$ for Stewart Platform', fontsize=16)\nplt.legend(fontsize=12)\nplt.grid(True)\n\n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n5B)\n\n\nShow Code\n# Provide new initial guesses to find six distinct roots for this configuration\ninitial_guesses = [-.7, -.4, .01, .4, .9, 2.5 ]  # Customize this list\n\n# Find and print the roots using the initial guesses\nroots = find_roots(constants, initial_guesses)\nprint(f\"The roots of f(θ) in the interval are : {roots}\")\n\n# Set up the 2x3 grid for plotting the six poses\nfig, axes = plt.subplots(2, 3, figsize=(9, 6))  # Create a 2x3 grid\naxes = axes.flatten()  # Flatten the 2D array of axes for easier access\n\n# Get the anchor points\nanchor_points = get_anchor_points(constants)\n\n# Loop through the six roots and plot each pose\nfor i, theta in enumerate(roots[:6]):\n    x, y = get_x_y(theta, constants)\n    points = get_points(x, y, theta, constants)\n    # Plot the triangle in the corresponding subplot with custom limits\n    plot_triangle(axes[i], points, anchor_points, x_limits=(-5.5, 5.5), y_limits=(-.5, 10), )\n    axes[i].set_title(rf\"$\\theta$ = {theta}\")\n\n    # Calculate and verify strut lengths\n    lengths = calculate_strut_lengths(points, anchor_points)\n    print(f\"For root {np.round(theta, 3)}, strut lengths are: {np.round(lengths)}\")\n    print(f\"Expected: p1={constants.p1}, p2={constants.p2}, p3={constants.p3}\\n\")\n\n# Turn off any unused subplots (though in this case, we should have exactly 6)\nfor j in range(len(roots), 6):\n    axes[j].axis('off')\n\n# Adjust layout\nplt.tight_layout()\n\n\nplt.show()\n\n\nThe roots of f(θ) in the interval are : [-0.67315749 -0.35474027  0.03776676  0.45887818  0.9776729   2.5138528 ]\nFor root -0.673, strut lengths are: [5. 7. 3.]\nExpected: p1=5, p2=7, p3=3\n\nFor root -0.355, strut lengths are: [5. 7. 3.]\nExpected: p1=5, p2=7, p3=3\n\nFor root 0.038, strut lengths are: [5. 7. 3.]\nExpected: p1=5, p2=7, p3=3\n\nFor root 0.459, strut lengths are: [5. 7. 3.]\nExpected: p1=5, p2=7, p3=3\n\nFor root 0.978, strut lengths are: [5. 7. 3.]\nExpected: p1=5, p2=7, p3=3\n\nFor root 2.514, strut lengths are: [5. 7. 3.]\nExpected: p1=5, p2=7, p3=3\n\n\n\n\n\n\n\n\n\n\n\n\n\nPROBLEM 6\n\n\nFind a strut length p_2, with the rest of the parameters as in Step 4, for which there are only two poses.\nTo identify a strut length for p_2 that results in exactly two poses for the Stewart platform I systematically adjusted p_2 and utilizing the fsolve function to find the corresponding roots of the function f(\\theta). This method enabled me to determine a specific p_2 value that achieves the desired two-pose configuration.\n\n\nShow Code\n# Set a threshold for considering a valid root (how close to zero we want f(theta) to be)\nROOT_THRESHOLD = 1e-6\n\n# Function to find roots for a given p2, and check if they are valid\ndef find_roots_for_p2(p2_value, constants, initial_guesses, ax=None):\n    \"\"\"\n    Adjusts p2 in the constants object, finds the roots, and returns the number of unique roots.\n    Also plots f(theta) for the current p2 value on the provided axis.\n    \"\"\"\n    # Update p2 in constants\n    constants.p2 = p2_value\n\n    # Generate theta values and compute f(theta)\n    theta_values = np.linspace(-np.pi, np.pi, 400)\n    f_values = [f(theta, constants) for theta in theta_values]\n\n    # Plot f(theta) for the current p2 value on the provided axis\n    ax.plot(theta_values, f_values,)\n    ax.axhline(0, color='black', linestyle='--', linewidth=0.8)\n    ax.set_xlabel(r'$\\theta$', fontsize=14)\n    ax.set_ylabel(r'$f(\\theta)$', fontsize=14)\n    ax.set_title(fr'$p_2 = {p2_value:.3f}$')\n    ax.legend(fontsize=10)\n    ax.grid(True)\n\n    # Find the roots for the given p2 value\n    roots = []\n    for guess in initial_guesses:\n        root = fsolve(f, guess, args=(constants))[0]\n\n        # Check if the found root is valid (i.e., f(root) is close to zero)\n        if abs(f(root, constants)) &lt; ROOT_THRESHOLD:\n            roots.append(root)\n\n    # Convert to numpy array and round the roots to avoid precision issues\n    roots = np.round(np.array(roots), decimals=6)\n    unique_roots = np.unique(roots)\n\n    # Print the number of valid roots and the roots themselves\n    print(f\"p2 = {p2_value:.3f}: Found {len(unique_roots)} valid roots: {unique_roots}\")\n\n    return unique_roots\n\n# Function to iterate over possible p2 values and append plots in a grid (wrap after 3)\ndef find_p2_with_two_roots(constants, initial_guesses, p2_start=-1, total_plots=6):\n    \"\"\"\n    Iterates over possible p2 values starting at p2_start, plots f(theta), and prints the number of roots.\n    The plots wrap after 3 per row.\n\n    Parameters:\n    - constants: The Constants object.\n    - initial_guesses: List of initial guesses for root finding.\n    - p2_start: Starting value of p2.\n    - total_plots: Number of plots to show before stopping.\n    \"\"\"\n    p2 = p2_start\n    plot_count = 0\n    max_plots_per_row = 3  # Wrap after 3 plots per row\n\n    # Calculate the number of rows needed (wrap after 3)\n    num_rows = (total_plots + max_plots_per_row - 1) // max_plots_per_row\n\n    # Create a figure with a 3xN grid\n    fig, axes = plt.subplots(num_rows, max_plots_per_row, figsize=(10, num_rows * 3))\n    axes = axes.flatten()  # Flatten the 2D array of axes for easier access\n    fig.subplots_adjust(hspace=0.3, wspace=0.3)  # Adjust the space between subplots\n\n    # Iterate to plot p2 and find roots\n    while plot_count &lt; total_plots:\n        # Plot for the current p2 value and check the roots\n        unique_roots = find_roots_for_p2(p2, constants, initial_guesses, ax=axes[plot_count])\n\n        if len(unique_roots) == 2:  # Check if there are exactly 2 unique roots\n            print(f\"Found p2={p2} with two distinct roots: {unique_roots}\")\n\n        # Increment p2 and plot the next iteration\n        p2 += 1\n        plot_count += 1\n\n    # Show the final figure with all appended plots\n    plt.tight_layout()\n\n\n    plt.show()\n\n# Example constants (with p2 placeholder)\nconstants = Constants(\n    l1=3,\n    l2=3 * np.sqrt(2),\n    l3=3,\n    gamma=np.pi / 4,\n    x1=5,\n    x2=0,\n    y2=6,\n    p1=5,\n    p2=None,  # To be found\n    p3=3\n)\n\n# Initial guesses for root finding\ninitial_guesses = [-np.pi/2, 0, np.pi/2]\n\n# Start p2 at -1 and increment by 1 each time, looking for exactly 2 roots\nfind_p2_with_two_roots(constants, initial_guesses, p2_start=-1, total_plots=6)\n\n\np2 = -1.000: Found 0 valid roots: []\np2 = 0.000: Found 0 valid roots: []\np2 = 1.000: Found 0 valid roots: []\np2 = 2.000: Found 0 valid roots: []\np2 = 3.000: Found 0 valid roots: []\np2 = 4.000: Found 2 valid roots: [1.331642 1.777514]\nFound p2=4 with two distinct roots: [1.331642 1.777514]\n\n\n\n\n\n\n\n\n\n\n\n\nPROBLEM 7\n\n\nCalculate the intervals in p_2, with the rest of the parameters as in Step 4, for which there are 0, 2, 4, and 6 poses, respectively.\nIn transitioning from Problem 6 to Problem 7, I found that using fsolve with predefined initial guesses was too inaccurate for reliably identifying roots. This method often missed valid roots or produced duplicates due to its sensitivity to starting points. To improve accuracy, I switched to detecting sign changes in the function f(\\theta) and used the brentq algorithm, which efficiently locates roots where the function changes from positive to negative or vice versa. This approach greatly improved the precision of root detection.\n\n\nShow Code\ndef count_roots(constants, theta_min=-np.pi, theta_max=np.pi, num_points=1000):\n    \"\"\"\n    Counts roots of f(theta) = 0 within [theta_min, theta_max].\n\n    Parameters:\n    constants (Constants): Stewart platform constants.\n    theta_min (float): Lower bound of theta.\n    theta_max (float): Upper bound of theta.\n    num_points (int): Sampling points.\n\n    Returns:\n    int: Number of unique roots.\n    list: Root values.\n    \"\"\"\n    theta_vals = np.linspace(theta_min, theta_max, num_points)\n\n    # Evaluate f(theta) over the range\n    f_vals = np.array([f(theta, constants) for theta in theta_vals])\n\n    roots = []\n\n    # Detect sign changes indicating roots\n    for i in range(len(theta_vals)-1):\n        if np.sign(f_vals[i]) != np.sign(f_vals[i+1]):\n            try:\n                root = brentq(f, theta_vals[i], theta_vals[i+1], args=(constants,))\n                if theta_min &lt;= root &lt;= theta_max:\n                    roots.append(root)\n            except ValueError:\n                pass  # No root in this interval\n\n    # Eliminate duplicate roots\n    unique_roots = []\n    for r in roots:\n        if not any(np.isclose(r, ur, atol=1e-5) for ur in unique_roots):\n            unique_roots.append(r)\n\n    return len(unique_roots), unique_roots\n\ndef find_p2_intervals(constants, p2_min, p2_max, p2_step):\n    \"\"\"\n    Finds p2 intervals with specific numbers of roots.\n\n    Parameters:\n    constants (Constants): Stewart platform constants.\n    p2_min (float): Starting p2 value.\n    p2_max (float): Ending p2 value.\n    p2_step (float): Increment step for p2.\n\n    Returns:\n    dict: Pose counts as keys and p2 lists as values.\n    \"\"\"\n    p2_values = np.arange(p2_min, p2_max + p2_step, p2_step)\n    root_counts = {0: [], 2: [], 4: [], 6: []}\n\n    for p2 in p2_values:\n        constants.p2 = p2\n        num_roots, _ = count_roots(constants)\n        if num_roots in root_counts:\n            root_counts[num_roots].append(p2)\n\n    return root_counts\n\n#### 4. Implement Problem 7\n\n# Initialize constants\nconstants = Constants(\n    l1=3,\n    l2=3 * np.sqrt(2),\n    l3=3,\n    gamma=np.pi / 4,\n    x1=5,\n    x2=0,\n    y2=6,\n    p1=5,\n    p2=5,  # Initial p2; will be varied\n    p3=3\n)\n\n# Set p2 range\np2_min = 0.0\np2_max = 12.98  # Extended to capture p2 &gt;= 9.27\np2_step = 0.01\n\n# Get root counts\nroot_counts = find_p2_intervals(constants, p2_min, p2_max, p2_step)\n\n# Plotting\nplt.figure(figsize=(12, 6))\ncolors = {0: 'blue', 2: 'green', 4: 'orange', 6: 'red'}\n\nfor num_roots, p2_list in root_counts.items():\n    plt.scatter(p2_list, [num_roots]*len(p2_list), label=f'{num_roots} poses', s=10, color=colors.get(num_roots, 'grey'))\n\nplt.xlabel('$p_2$', fontsize=14)\nplt.ylabel('Number of Poses (Roots)', fontsize=14)\nplt.title('Number of Poses vs Length of Strut $p_2$', fontsize=16)\nplt.legend()\nplt.grid(True)\n\nplt.show()\n\n# Identify intervals\nintervals_dict = {0: [], 2: [], 4: [], 6: []}\ntol = 1e-6  # Tolerance for precision\n\nfor num_roots, p2_list in root_counts.items():\n    if p2_list:\n        p2_sorted = np.sort(p2_list)\n        diffs = np.diff(p2_sorted)\n        split_indices = np.where(diffs &gt; (p2_step + tol))[0] + 1\n        intervals = np.split(p2_sorted, split_indices)\n\n        for interval in intervals:\n            p2_start, p2_end = interval[0], interval[-1]\n            intervals_dict[num_roots].append((p2_start, p2_end))\n\n# Print first and last intervals for each pose count\nfor num_roots, intervals in intervals_dict.items():\n    if intervals:\n        print(f\"\\nIntervals with {num_roots} poses:\")\n        if len(intervals) == 1:\n            p2_start, p2_end = intervals[0]\n            p2_end_str = \"infinity\" if np.isclose(p2_end, p2_max, atol=tol) else f\"{p2_end:.2f}\"\n            print(f\"  p2 from {p2_start:.2f} to {p2_end_str}\")\n        else:\n            # First interval\n            p2_start, p2_end = intervals[0]\n            p2_end_str = \"infinity\" if np.isclose(p2_end, p2_max, atol=tol) else f\"{p2_end:.2f}\"\n            print(f\"  p2 from {p2_start:.2f} to {p2_end_str}\")\n\n            # Last interval\n            p2_start, p2_end = intervals[-1]\n            p2_end_str = \"infinity\" if np.isclose(p2_end, p2_max, atol=tol) else f\"{p2_end:.2f}\"\n            print(f\"  p2 from {p2_start:.2f} to {p2_end_str}\")\n\n\n\n\n\n\n\n\n\n\nIntervals with 0 poses:\n  p2 from 0.00 to 3.71\n  p2 from 9.27 to infinity\n\nIntervals with 2 poses:\n  p2 from 3.72 to 4.86\n  p2 from 7.85 to 9.26\n\nIntervals with 4 poses:\n  p2 from 4.87 to 6.96\n  p2 from 7.03 to 7.84\n\nIntervals with 6 poses:\n  p2 from 6.97 to 7.02"
  },
  {
    "objectID": "worksheets/index.html",
    "href": "worksheets/index.html",
    "title": "WORKSHEETS",
    "section": "",
    "text": "Jacobi Method - Convergence Proof"
  },
  {
    "objectID": "notes/w12/root-of-unity.html",
    "href": "notes/w12/root-of-unity.html",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "",
    "text": "Roots of unity are solutions to the equation:\n\nz^n = 1\n\nwhere z is a number (real or complex) and n is a positive integer. These solutions represent the numbers that, when multiplied by themselves n times, equal 1."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#roots-of-unity-the-basic-idea",
    "href": "notes/w12/root-of-unity.html#roots-of-unity-the-basic-idea",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "",
    "text": "Roots of unity are solutions to the equation:\n\nz^n = 1\n\nwhere z is a number (real or complex) and n is a positive integer. These solutions represent the numbers that, when multiplied by themselves n times, equal 1.\n\n\n\n\nIn the real numbers, the equation z^n = 1 has at most two solutions:\n\nz = 1 (the trivial solution).\nz = -1, but only when n is even.\n\n\n\n\nPrimitive roots of unity are roots that generate all roots of unity through their powers. In the real numbers:\n\nz = 1: Trivial root, but it cannot generate anything else. Not primitive.\nz = -1: Primitive for even n, as it alternates between 1 and -1.\n\nThus, in the real numbers:\n\nFor n = 2, the primitive root is -1.\nFor n &gt; 2, there are no new primitive roots in the reals.\n\nThis limitation motivates expanding the idea to the complex plane.\n\n\n\n\n\n\nTo find all solutions to z^n = 1 in the complex plane, we use Euler’s formula:\n\nz = e^{i \\theta} = \\cos(\\theta) + i \\sin(\\theta),\n\nwhere \\theta is the angle (in radians) of z on the unit circle in the complex plane. The general solution to z^n = 1 is:\n\nz_k = e^{i \\frac{2\\pi k}{n}}, \\quad k = 0, 1, \\dots, n-1\n\nThese solutions are the n-th roots of unity. They are equally spaced points on the unit circle, with angles:\n\n\\theta_k = \\frac{2\\pi k}{n}\n\n\n\n\nFor z^4 = 1, the roots are:\n\nz_0 = e^{i \\frac{2\\pi \\cdot 0}{4}} = e^{i 0} = 1,\nz_1 = e^{i \\frac{2\\pi \\cdot 1}{4}} = e^{i \\frac{\\pi}{2}} = i,\nz_2 = e^{i \\frac{2\\pi \\cdot 2}{4}} = e^{i \\pi} = -1,\nz_3 = e^{i \\frac{2\\pi \\cdot 3}{4}} = e^{i \\frac{3\\pi}{2}} = -i.\n\nThese roots are \\{1, i, -1, -i\\}, representing four equally spaced points on the unit circle.\n\n\n\n\n\n\nA root of unity z is primitive if it generates all n-th roots of unity through its successive powers.\nFormally:\n\nz is primitive if z^k \\neq 1 for 1 \\leq k &lt; n, and z^n = 1.\n\n\n\n\nThe 4th roots of unity are \\{1, i, -1, -i\\}. Let’s test each root:\n\nz = 1: 1^k = 1 for all k. Not primitive.\nz = i:\n\ni^1 = i,\ni^2 = -1,\ni^3 = -i,\ni^4 = 1 (cycles through all roots). Primitive.\n\nz = -1:\n\n(-1)^1 = -1,\n(-1)^2 = 1 (only alternates between -1 and 1). Not primitive.\n\nz = -i:\n\n(-i)^1 = -i,\n(-i)^2 = -1,\n(-i)^3 = i,\n(-i)^4 = 1. Primitive.\n\n\nThus, the primitive roots for n = 4 are i and -i.\n\n\n\n\nRoots of unity lie on the unit circle in the complex plane, evenly spaced at angles \\frac{2\\pi}{n}. For n = 4:\n\nz_0 = 1 at 0^\\circ,\nz_1 = i at 90^\\circ,\nz_2 = -1 at 180^\\circ,\nz_3 = -i at 270^\\circ.\n\nPrimitive roots, like i, act as the “generator,” visiting each point exactly once when raised to successive powers.\n\n\n\n\nIn Algebra:\n\nRoots of unity are solutions to the polynomial z^n - 1 = 0, which is foundational in field theory and Galois theory.\n\nIn Fourier Analysis:\n\nThe Discrete Fourier Transform (DFT) uses primitive roots to decompose signals into frequency components.\n\nIn Number Theory:\n\nRoots of unity appear in modular arithmetic, cyclotomic fields, and cryptography.\n\n\n\n\n\n\nReal Numbers: Only 1 and -1 are roots of unity, and -1 is primitive for n = 2.\nComplex Plane: Extending to complex numbers introduces all n-th roots of unity, equally spaced on the unit circle.\nPrimitive Roots: These roots generate all other roots through successive powers, playing a central role in algebra, signal processing, and number theory."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#overview",
    "href": "notes/w12/root-of-unity.html#overview",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "",
    "text": "Roots of unity are solutions to the equation:\n\nz^n = 1\n\nwhere z is a number (real or complex) and n is a positive integer. These solutions represent the numbers that, when multiplied by themselves n times, equal 1."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#roots-of-unity-in-real-numbers",
    "href": "notes/w12/root-of-unity.html#roots-of-unity-in-real-numbers",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "Roots of Unity in Real Numbers",
    "text": "Roots of Unity in Real Numbers\n\nWhat Are They?\nIn the real numbers, the equation z^n = 1 has at most two solutions:\n\nz = 1 (the trivial solution).\nz = -1, but only when n is even.\n\n\n\nPrimitive Roots in Real Numbers\nPrimitive roots of unity are roots that generate all roots of unity through their powers. In the real numbers:\n\nz = 1: Trivial root, but it cannot generate anything else. Not primitive.\nz = -1: Primitive for even n, as it alternates between 1 and -1.\n\nThus, in the real numbers:\n\nFor n = 2, the primitive root is -1.\nFor n &gt; 2, there are no new primitive roots in the reals.\n\nThis limitation motivates expanding the idea to the complex plane."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#extending-roots-of-unity-to-the-complex-plane",
    "href": "notes/w12/root-of-unity.html#extending-roots-of-unity-to-the-complex-plane",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "Extending Roots of Unity to the Complex Plane",
    "text": "Extending Roots of Unity to the Complex Plane\n\nComplex Roots of Unity\nTo find all solutions to z^n = 1 in the complex plane, we use Euler’s formula:\n\nz = e^{i \\theta} = \\cos(\\theta) + i \\sin(\\theta)\n\nwhere \\theta is the angle (in radians) of z on the unit circle in the complex plane. The general solution to z^n = 1 is:\n\nz_k = e^{i \\frac{2\\pi k}{n}}, \\quad k = 0, 1, \\dots, n-1\n\nThese solutions are the n-th roots of unity. They are equally spaced points on the unit circle, with angles:\n\n\\theta_k = \\frac{2\\pi k}{n}\n\n\n\nExample: 4th Roots of Unity (n = 4)\nFor z^4 = 1, the roots are:\n\nz_0 = e^{i \\frac{2\\pi \\cdot 0}{4}} = e^{i 0} = 1\nz_1 = e^{i \\frac{2\\pi \\cdot 1}{4}} = e^{i \\frac{\\pi}{2}} = i\nz_2 = e^{i \\frac{2\\pi \\cdot 2}{4}} = e^{i \\pi} = -1\nz_3 = e^{i \\frac{2\\pi \\cdot 3}{4}} = e^{i \\frac{3\\pi}{2}} = -i\n\nThese roots are \\{1, i, -1, -i\\}, representing four equally spaced points on the unit circle."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#primitive-roots-of-unity",
    "href": "notes/w12/root-of-unity.html#primitive-roots-of-unity",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "Primitive Roots of Unity",
    "text": "Primitive Roots of Unity\n\nWhat Makes a Root Primitive?\nA root of unity z is primitive if it generates all n-th roots of unity through its successive powers.\nFormally:\n\nz is primitive if z^k \\neq 1 for 1 \\leq k &lt; n, and z^n = 1\n\n\n\nExample: Primitive Roots for n = 4\nThe 4th roots of unity are \\{1, i, -1, -i\\}. Let’s test each root:\n\nz = 1: 1^k = 1 for all k. Not primitive.\nz = i:\n\ni^1 = i\ni^2 = -1\ni^3 = -i\ni^4 = 1 (cycles through all roots) Primitive\n\nz = -1:\n\n(-1)^1 = -1,\n(-1)^2 = 1 (only alternates between -1 and 1). Not primitive.\n\nz = -i:\n\n(-i)^1 = -i\n(-i)^2 = -1\n(-i)^3 = i\n(-i)^4 = 1 Primitive\n\n\nThus, the primitive roots for n = 4 are i and -i."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#visualizing-roots-of-unity",
    "href": "notes/w12/root-of-unity.html#visualizing-roots-of-unity",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "Visualizing Roots of Unity",
    "text": "Visualizing Roots of Unity\nRoots of unity lie on the unit circle in the complex plane, evenly spaced at angles \\frac{2\\pi}{n}. For n = 4:\n\nz_0 = 1 at 0^\\circ\nz_1 = i at 90^\\circ\nz_2 = -1 at 180^\\circ\nz_3 = -i at 270^\\circ\n\nPrimitive roots, like i, act as the “generator,” visiting each point exactly once when raised to successive powers."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#applications-of-roots-of-unity",
    "href": "notes/w12/root-of-unity.html#applications-of-roots-of-unity",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "Applications of Roots of Unity",
    "text": "Applications of Roots of Unity\n\nIn Algebra:\nRoots of unity are solutions to the polynomial z^n - 1 = 0, foundational in field theory and Galois theory.\nIn Fourier Analysis:\nThe Discrete Fourier Transform (DFT) uses primitive roots to decompose signals into frequency components.\nIn Number Theory:\nRoots of unity appear in modular arithmetic, cyclotomic fields, and cryptography."
  },
  {
    "objectID": "notes/w12/root-of-unity.html#summary",
    "href": "notes/w12/root-of-unity.html#summary",
    "title": "Roots of Unity: From Real Numbers to the Complex Plane",
    "section": "Summary",
    "text": "Summary\n\nReal Numbers: Only 1 and -1 are roots of unity, and -1 is primitive for n = 2.\nComplex Plane: Extending to complex numbers introduces all n-th roots of unity, equally spaced on the unit circle.\nPrimitive Roots: These roots generate all other roots through successive powers, playing a central role in algebra, signal processing, and number theory."
  }
]